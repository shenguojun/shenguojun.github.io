<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lawrence&#39;s Blog</title>
    <link>https://shenguojun.github.io/</link>
    <description>Recent content on Lawrence&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Nov 2023 16:37:24 +0800</lastBuildDate>
    <atom:link href="https://shenguojun.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tetris Native揭秘|有道词典动态化运营引擎</title>
      <link>https://shenguojun.github.io/post/tetris-native-overview/</link>
      <pubDate>Mon, 13 Nov 2023 16:37:24 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/tetris-native-overview/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Tetris Native是有道词典端侧动态渲染引擎，目前已作为多个业务的运营投放容器，支持跨端UI动态化发布及多种样式，助力有道词典流量变现。《Tetris Native揭秘》系列文章将详细介绍Tetris Native的设计理念和详细落地方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flutter入门1——Dart语言基础</title>
      <link>https://shenguojun.github.io/post/flutter-dart/</link>
      <pubDate>Thu, 01 Sep 2022 19:43:01 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/flutter-dart/</guid>
      <description>&lt;p&gt;Dart语言的某些特性可能会让习惯使用Java或者Kotlin的开发者看不懂或者感到疑惑，本文主要介绍Dart语言的一些和Java以及Kotlin不太一样的地方，旨在让Android开发者可以快速掌握Dart语言。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入理解Android Runtime</title>
      <link>https://shenguojun.github.io/post/android_runtime/</link>
      <pubDate>Mon, 08 Aug 2022 11:07:45 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android_runtime/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/shenguojun/ImageServer/master/uPic/android-stack_2x.png&#34; alt=&#34;Android Platform Architecture&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;上图是Android整体的架构，Android Runtime之于Android而言相当于心脏之于人体，是Android程序加载和运行的环境。这篇文章主要针对Android Runtime部分进行展开，探讨Android Runtime的发展以及目前现状，并介绍应用Profile-Guided Optimization(PGO)技术对应用启动速度进行优化的可行性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>TargetsdkVersion 升级31（Android12）适配</title>
      <link>https://shenguojun.github.io/post/targetsdk31/</link>
      <pubDate>Thu, 14 Apr 2022 11:01:07 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/targetsdk31/</guid>
      <description>&lt;h1 id=&#34;targetsdkversion-升级31android12适配&#34;&gt;TargetsdkVersion 升级31（Android12）适配&lt;/h1&gt;&#xA;&lt;p&gt;我们升级到Targetsdk29有大半年时间了，今年为了满足审查去除蓝牙的精确定位权限，以及满足上架Google Play的要求，需要将Targetsdkversion升级到31，适配到Android12。这个过程遇到不少坑，这里记录一下，希望能对大家有所帮助。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin升级1.5版本synthetic引发的血案分析</title>
      <link>https://shenguojun.github.io/post/kotlin_synthetic/</link>
      <pubDate>Fri, 09 Jul 2021 16:27:41 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/kotlin_synthetic/</guid>
      <description>&lt;h2 id=&#34;场景重现&#34;&gt;场景重现&lt;/h2&gt;&#xA;&lt;p&gt;因为项目里面Kotlin版本还停留在1.4，看到1.5版本&lt;a href=&#34;https://Kotlinlang.org/docs/releases.html#release-details&#34;&gt;更新记录&lt;/a&gt;提升了性能并且新加了一些特性，准备怒升级一波。怀着开心的心情升级完之后，运行起来就傻眼了！&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/shenguojun/ImageServer/master/uPic/1625820518128283.gif&#34; alt=&#34;1625820518128283&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;视频列表有个浮层没有隐藏，就升级下Kotlin，居然还有这个问题，真是太不可思议了！把Kotlin降级回去，然后就好了，确定是因为Kotlin升级导致的问题。接下来就开始分析了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android深色模式适配原理分析</title>
      <link>https://shenguojun.github.io/post/android-dark-mode/</link>
      <pubDate>Mon, 12 Oct 2020 13:06:52 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-dark-mode/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/shenguojun/ImageServer/master/uPic/dark-mode-hot-take.png&#34; alt=&#34;Dark Mode&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;从Android10（API 29）开始，在原有的主题适配的基础上，Google开始提供了Force Dark机制，在系统底层直接对颜色和图片进行转换处理，原生支持深色模式。到目前为止，我们从用户数据分析**50%**以上的用户已经使用上了Android10系统。深色模式可以节省电量、改善弱势及强光敏感用户的可视性，并能在环境亮度较暗的时候保护视力，更是夜间活跃用户的强烈需求。对深色模式的适配有利于提升用户口碑。 转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「申国骏」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flutter学习笔记——用户界面</title>
      <link>https://shenguojun.github.io/post/flutter-learning-note/</link>
      <pubDate>Tue, 07 Apr 2020 15:19:10 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/flutter-learning-note/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;以下为对&lt;a href=&#34;https://flutter.dev/docs&#34;&gt;Flutter官网&lt;/a&gt;的学习总结，如果你想快速掌握知识点，或者想复习一下官网学习的内容，那么值得看看。&#xA;转载请注明出处：&lt;a href=&#34;https://shenguojun.github.io/post/flutter-learning-note/&#34;&gt;Lawrence_Shen&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;用户界面&#34;&gt;用户界面&lt;/h1&gt;&#xA;&lt;h2 id=&#34;widgets介绍&#34;&gt;widgets介绍&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Flutter一切都是widget，包括设置padding的container。&lt;/li&gt;&#xA;&lt;li&gt;几乎所有widget都通过build方法声明其UI&lt;/li&gt;&#xA;&lt;li&gt;StatelessWidget用于固定样式的widget，StatefulWidget用于根据数据变化的widget。&lt;/li&gt;&#xA;&lt;li&gt;StatefulWidget通过createState关联私有的State对象，并通过setState()方法更新数据并通知UI变化。&lt;/li&gt;&#xA;&lt;li&gt;更新UI时Flutter会通过比较前后widget树来计算差异，widget只是保存了样式信息，它的重建可以考虑是轻量级的。widget树会对应到element树，并通过element树创建Render树。相同类型widget会重用element和render对象。&lt;/li&gt;&#xA;&lt;li&gt;State对象的生命周期跨越其对应的widget对象build方法，比widget本身生命周期要长&lt;/li&gt;&#xA;&lt;li&gt;State调用流程大致为initState -&amp;gt; build -&amp;gt; dispose，可以在initState做初始化操作，在dispose中做清理操作&lt;/li&gt;&#xA;&lt;li&gt;didChangeDependencies会在initState和build之间调用，当父widget有InheritedWidget变化时也会被调用&lt;/li&gt;&#xA;&lt;li&gt;InheritedWidget可用于在widget树中给子widget共享数据，通常通过of方法调用context.inheritFromWidgetOfExactType返回拥有共享数据的InheritedWidget对象&lt;/li&gt;&#xA;&lt;li&gt;key控制widget重建时与哪些其他widget进行匹配，从而保持正确的state状态，一般用在widget的添加删除或者重排序中控制widget重用&lt;/li&gt;&#xA;&lt;li&gt;key分为Local key（value key表示根据某个值判断、Object key表示根据某个对象判断、Unique key表示每个widget都不一样） 和Global key(表示不同页面的widget共享)，&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;构建layouts&#34;&gt;构建layouts&lt;/h2&gt;&#xA;&lt;h3 id=&#34;flutter中的layouts&#34;&gt;Flutter中的layouts&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以通过Row和Column构建复杂页面&lt;/li&gt;&#xA;&lt;li&gt;mainAxisAlignment控制主轴对齐方式，crossAxisAlignment控制次轴对齐方式&lt;/li&gt;&#xA;&lt;li&gt;使用Expanded widget来fit window，flex来指定比例&lt;/li&gt;&#xA;&lt;li&gt;将布局widget赋值给变量，通过变量组合布局减少层级嵌套&lt;/li&gt;&#xA;&lt;li&gt;使用Container设置margin、border、pandding和背景&lt;/li&gt;&#xA;&lt;li&gt;GridView.extend中maxCrossAxisExtent设置每个item的最大宽度，mainAxisSpacing设置主轴item之间的间隔，crossAxisSpacing设置次轴item之间的间隔，childAspectRatio设置item宽高比例&lt;/li&gt;&#xA;&lt;li&gt;GridView.builder用于数量较多的item展示，仅加载当前可见的部分，GridView.count用于加载少量固定数目的item并指定每行item格式，GridView.extend用于加载少量固定item并指定每行item最大宽度&lt;/li&gt;&#xA;&lt;li&gt;GridView中通过SliverGridDelegate控制子widget如何布局，通过SliverChildDelegate来获取子widget，可以通过自定义Delegate来实现自由或者叠加布局。&lt;/li&gt;&#xA;&lt;li&gt;GridView和ListView都继承自BoxScrollView&lt;/li&gt;&#xA;&lt;li&gt;大量数据需使用ListView.builder并在itemBuilder回调中创建并提供widget；如果列表的item样式可以提前构建则可以直接使用new ListView；ListView.separated除了itemBuilder之外还有个separatorBuilder用来定义分隔线样式；ListView.custom通过提供自定义的SliverChildDelegate来实现自定义的列表加载和缓存逻辑。&lt;/li&gt;&#xA;&lt;li&gt;Stack用于widget的堆叠，可以做渐变的图片阴影&lt;/li&gt;&#xA;&lt;li&gt;Card内部内容不能够滚动，可以自定义圆角和阴影大小&lt;/li&gt;&#xA;&lt;li&gt;ListTitle是方便构建至多三行文字加上前后图标的列表item widget&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;layout使用例子&#34;&gt;layout使用例子&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用Expanded widget占满剩余空间，子widget设置CrossAxisAlignment.start表示从前开始&lt;/li&gt;&#xA;&lt;li&gt;Text softwrap控制是否需要自动换行&lt;/li&gt;&#xA;&lt;li&gt;修改pubspec.yaml设置assets目录，例如：flutter: assets: [images/]&lt;/li&gt;&#xA;&lt;li&gt;Image.asset中设置fit:BoxFit.cover 表示图片应该以最小的大小占满box空间&lt;/li&gt;&#xA;&lt;li&gt;使用ListView代替Column保证小屏幕手机中空间可以滚动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;创建自适应ui应用&#34;&gt;创建自适应UI应用&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用LayoutBuilder的BoxConstraints获取当前widget的宽高比例从而调整子widget布局&lt;/li&gt;&#xA;&lt;li&gt;使用MediaQuery.of()获取屏幕宽高和旋转方向等设备信息从而控制整体布局样式&lt;/li&gt;&#xA;&lt;li&gt;AspectRatio控制子widget的宽高比例&lt;/li&gt;&#xA;&lt;li&gt;CustomSingleChildLayout、CustomMultiChildLayout将子widget的布局委托给ChildLayoutDelegate进行控制&lt;/li&gt;&#xA;&lt;li&gt;FittedBox：当子widget比父widget大时，通过FittedBox可以设置子widget的缩放方式&lt;/li&gt;&#xA;&lt;li&gt;FractionallySizedBox可以设置子widget占据其空间的宽高百分比&lt;/li&gt;&#xA;&lt;li&gt;MediaQueryData中padding指代周边有多少不能绘制的区域不计算被键盘等遮挡的区域，viewPadding指的是周边有多少不能被绘制的区域不受键盘等遮挡影响，viewInsert表示周边有多少区域被键盘等遮挡了&lt;/li&gt;&#xA;&lt;li&gt;OrientationBuilder获取屏幕是否旋转&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;constraints布局约束理解&#34;&gt;Constraints布局约束理解&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;布局流程：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;widget从parent中获取四个约束，分别是最小和最大宽度、最小和最大高度；&lt;/li&gt;&#xA;&lt;li&gt;widget将约束一个一个地传递给子widget，并让子widget根据约束条件设定其自身的大小；&lt;/li&gt;&#xA;&lt;li&gt;widget根据子widget的大小一个一个进行布局；&lt;/li&gt;&#xA;&lt;li&gt;widget将自身的大小上报给parent。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;布局流程会导致以下三个限制：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个widget最终布局大小需要受到parent的约束限制，不是想要什么大小都可以；&lt;/li&gt;&#xA;&lt;li&gt;一个widget不能知道也不能决定其在屏幕中的位置，widget的布局由其parent决定；&lt;/li&gt;&#xA;&lt;li&gt;只有考虑整棵widget树才能确定widget的大小和位置，不能准确地定义某个widget的位置和大小。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Container布局行为：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;若没有子widget，没有设置宽高，没有约束，parent是无界约束，Container会填充parent，并希望让自身尽量的小&lt;/li&gt;&#xA;&lt;li&gt;若没有子widget，没有设置alignment，设置了宽高或者有约束，Container会在满足自身约束和parent约束的情况下尽量的小&lt;/li&gt;&#xA;&lt;li&gt;若没有子widget，没有设置宽高，没有约束，没有设置alignment，parent是有界约束，那么Container会尽量的扩大以满足parent的约束&lt;/li&gt;&#xA;&lt;li&gt;若设置了alignment，parent无界约束，那么Container尽量缩小为子widget大小&lt;/li&gt;&#xA;&lt;li&gt;若设置了alignment，parent有界约束，那么Container扩大为parent约束大小，并将子widget根据alignment设置来布局&lt;/li&gt;&#xA;&lt;li&gt;若只有子widget，没有设置宽高，没有约束，没有alignment，Container会将parent的约束传递给子widget，并尽量缩小为子widget大小&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;布局中FittedBox可以控制子widget在约束空间中的布局，例如设置自动缩小文字或者缩放图片&lt;/li&gt;&#xA;&lt;li&gt;tight约束表示固定宽高约束，loose约束表示在设置最大宽高基础上尽量的缩小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;box-constraints边界约束&#34;&gt;Box constraints边界约束&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有三种box，分别是无限扩展例如Center或者ListView、子widget决定例如Trnasform和Opacity、固定大小例如Image和Text&lt;/li&gt;&#xA;&lt;li&gt;类似于当一个竖向的ListView嵌套进了一个横向的ListView，会造成无界约束状态（Unbounded constraints），这种状态会使得子widget可以在两个方向无限扩展导致错误&lt;/li&gt;&#xA;&lt;li&gt;Flex boxs指的是Row和Column，表示当其处于一个有界的区域会不断扩展至给定大小，当其处于一个无界区域会适应他的子widget大小。&lt;/li&gt;&#xA;&lt;li&gt;如果将Flex box放置于类似于ListView的widget中，那么flex box中不能有类似于Expanded的widget，这会导致类似于Expanded的widget无限扩大造成错误&lt;/li&gt;&#xA;&lt;li&gt;Column的宽度和Row的高度不能设置为无界的，否则他们的子widget将无法布局&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;加入互动逻辑&#34;&gt;加入互动逻辑&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可交互的widget有三点，一是有两个类，分别继承StatefulWidget和State，二是State类中拥有可变的状态和build方法，三是当状态变化，调用setState()方法对widget进行重绘。&lt;/li&gt;&#xA;&lt;li&gt;将Text放在SizedBox中可以防止当文字变化时由于宽度变化带来的位置抖动&lt;/li&gt;&#xA;&lt;li&gt;当调用setState({})方法时，会先执行lambda逻辑，然后调用_element.markNeedsBuild()标记当前element为dirty状态并在下一帧根据修改后的状态进行重绘&lt;/li&gt;&#xA;&lt;li&gt;有三种常见的管理状态方法，分别是：widget自己管理自己的状态、父widget管理状态、混合前两种方式&lt;/li&gt;&#xA;&lt;li&gt;如果状态是用户数据，那么最好在父widget管理。如果状态是与界面效果有关的例如动画，那么最好在widget自身内管理状态。如果不确定最好先在父widget中管理，因为大多数情况外层需要对状态数据进行处理并更新子widget，外层处理状态也有利于子widget保持整洁。当widget既包含用户状态又包含外部不关注的自身界面效果状态则使用混合状态管理模式。&lt;/li&gt;&#xA;&lt;li&gt;对于必须传入的参数使用@require注解&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;添加assets和图片&#34;&gt;添加assets和图片&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在pubspec.yaml中声明assets文件夹的路径声明，如果需要添加子文件夹的话需要单独列出&lt;/li&gt;&#xA;&lt;li&gt;声明assets时会同时查找其定义的子文件夹是否有同名的文件，如果有的话会把同名的文件同时引入，这是为了方便引入不同分辨率的图片资源&lt;/li&gt;&#xA;&lt;li&gt;使用DefaultAssetBundle.of(context).load()或loadString()方法加载asset文本资源，其中context最好使用当前widget的BuildContext，这有利于父widget在测试或者本地化时在运行时替换不同的AssetBundle。&lt;/li&gt;&#xA;&lt;li&gt;当不能获取widget context的地方，可以使用rootBundle来加载文本资源&lt;/li&gt;&#xA;&lt;li&gt;对于图片资源，可以使用相同的图片命名并放在2.0x和3.0x文件夹中，不同dp/px比例的手机会自动选用合适大小的资源&lt;/li&gt;&#xA;&lt;li&gt;使用AssetImage加载图片会自动选择对应分辨率的图片，如果需要加载不同package的图片，需要在AssetImange中指定package&lt;/li&gt;&#xA;&lt;li&gt;对于不在同一个package的图片资源，也需要在pubspec.yaml文件中定义，例如需要引用package为fancy_backgrounds的图资源，需要在当前的pubspec.yaml中定义assets路径为packages/fancy_backgrounds/xxx(图片在fancy_backgrounds中libs目录下的相对位置)&lt;/li&gt;&#xA;&lt;li&gt;在Android中使用flutter的asset资源，使用PluginRegistry.Registrar.lookupKeyForAsset()方法获取key，并使用AssetManager.openFd(key)方法获取AssetFileDescriptor&lt;/li&gt;&#xA;&lt;li&gt;在iOS中使用flutter的asset资源，可以使用registrar lookupKeyForAsset或者key，然后通过mainBundle pathForResource:key ofType获取asset路径。如果使用了ios_platform_images插件，那么可以直接使用OC中的UIImage flutterImageWithName或者Swift中的UIImage.flutterImageNamed获取。&lt;/li&gt;&#xA;&lt;li&gt;flutter中使用iOS的图片可以使用ios_platform_images插件中的IosPlatformImages.load方法&lt;/li&gt;&#xA;&lt;li&gt;启动页会在Flutter绘制第一帧的时候被替换，如果在main方法中不调用runApp方法，那么启动页将一直展示。&lt;/li&gt;&#xA;&lt;li&gt;加入启动页的方式需要使用Android和iOS的本身的方式加入。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;页面导航&#34;&gt;页面导航&lt;/h2&gt;&#xA;&lt;h3 id=&#34;导航至新页面并返回&#34;&gt;导航至新页面并返回&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;route在安卓中相当于Activity，在iOS中相当于ViewController，在Flutter中，route表示的只是一个widget&lt;/li&gt;&#xA;&lt;li&gt;页面导航的步骤：创建两个route，使用Navigator.push()导航到第二个route，使用Navigator.pop()返回到上一个route&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MaterialPageRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;builder:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecondRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;通过创建MaterialPageRoute适配安卓和iOS页面跳转的动效，通过设置maintainState释放上一个页面的内存，通过fullscreenDialog设置是否全屏dialog样式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;使用具名路由跳转&#34;&gt;使用具名路由跳转&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当页面之间跳转较多时，在MaterialApp中声明路由关系，然后使用具名路由导航Navigator.pushNamed()可以减少代码重复&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;MaterialApp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Start the app with the &amp;#34;/&amp;#34; named route. In this case, the app starts&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// on the FirstScreen widget.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nl&#34;&gt;initialRoute:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nl&#34;&gt;routes:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// When navigating to the &amp;#34;/&amp;#34; route, build the FirstScreen widget.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FirstScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// When navigating to the &amp;#34;/second&amp;#34; route, build the SecondScreen widget.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;/second&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SecondScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pushNamed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;/second&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;非具名路由之间传递数据&#34;&gt;非具名路由之间传递数据&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用非具名路由跳转有两种页面间传递数据的做法，一种是跳转新页面时在Widget的构造函数中传入数据；第二种是通过设置MaterialPageRoute的RouteSettings中的arguments，并在跳转页面中使用ModalRoute.of(context).settings.arguments获取&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第一种方法&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;MaterialPageRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nl&#34;&gt;builder:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DetailScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;todo:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;todos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第二种方法—设置参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;MaterialPageRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nl&#34;&gt;builder:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DetailScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;// Pass the arguments as part of the RouteSettings. The&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// DetailScreen reads the arguments from these settings.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nl&#34;&gt;settings:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RouteSettings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nl&#34;&gt;arguments:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;todos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第二种方法—获取参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Todo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;todo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ModalRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;具名路由之间传递数据&#34;&gt;具名路由之间传递数据&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用具名路由跳转有两种页面间传输的做法，一种是使用Navigator.pushNamed并设置arguments，然后在跳转页面使用ModalRoute.of(context).settings.arguments获取；第二种是是使用Navigator.pushNamed并设置arguments，然后在MaterialApp的onGenerateRoute方法中获取settings.arguments并在返回的MaterialPageRoute中通过构造函数设置给跳转页面&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第一种方法—设置&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pushNamed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;ExtractArgumentsScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;routeName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nl&#34;&gt;arguments:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ScreenArguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;Extract Arguments Screen&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;This message is extracted in the build method.&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第一种方法—获取&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ScreenArguments&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ModalRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 第二种方法—通过onGenerateRoute方法构造目标页面并传递参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;MaterialApp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// Provide a function to handle named routes. Use this function to&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// identify the named route being pushed, and create the correct&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// screen.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nl&#34;&gt;onGenerateRoute:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// If you push the PassArguments route&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PassArgumentsScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;routeName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// Cast the arguments to the correct type: ScreenArguments.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ScreenArguments&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;settings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arguments&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// Then, extract the required data from the arguments and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// pass the data to the correct screen.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MaterialPageRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nl&#34;&gt;builder:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PassArgumentsScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nl&#34;&gt;title:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nl&#34;&gt;message:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;从目标页面返回数据&#34;&gt;从目标页面返回数据&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用Navigator.pop设置数据，并使用await获取Navigator.push返回结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 设置数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Yep!&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 获取数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Navigator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;MaterialPageRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;builder:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nextScreen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;动画&#34;&gt;动画&lt;/h2&gt;&#xA;&lt;h3 id=&#34;implicit动画&#34;&gt;Implicit动画&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于普通的修改大小和形状等的属性动画可以使用Implicit动画，设置动画时间duration、动画效果curve。常用的Implicit动画有以下这些：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Align -&amp;gt; AnimatedAlign&lt;/li&gt;&#xA;&lt;li&gt;Container -&amp;gt; AnimatedContainer&lt;/li&gt;&#xA;&lt;li&gt;DefaulTextStyle -&amp;gt; AnimatedDefaulTextStyle&lt;/li&gt;&#xA;&lt;li&gt;Opacity -&amp;gt; AnimatedOpacity&lt;/li&gt;&#xA;&lt;li&gt;Padding -&amp;gt; AnimatedPadding&lt;/li&gt;&#xA;&lt;li&gt;PhysicalModel -&amp;gt; AnimatedPhysicalModel&lt;/li&gt;&#xA;&lt;li&gt;Positioned -&amp;gt; AnimatedPositioned&lt;/li&gt;&#xA;&lt;li&gt;PositionedDirectional -&amp;gt; AnimatedPositionedDirectional&lt;/li&gt;&#xA;&lt;li&gt;Theme -&amp;gt; AnimatedThemeSize -&amp;gt; AnimatedSize&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;若没有能满足需求的Implicit动画widget，那么可以尝试使用TweenAnimationBuilder来实现自定义属性动画&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;explicit动画&#34;&gt;Explicit动画&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果想要对动画进行播放控制，那么需要使用Explicit动画，并在turns中指定AnimationController。常用的Explicit动画有以下这些：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SizeTransition&lt;/li&gt;&#xA;&lt;li&gt;FadeTransition&lt;/li&gt;&#xA;&lt;li&gt;AlignTransition&lt;/li&gt;&#xA;&lt;li&gt;ScaleTransition&lt;/li&gt;&#xA;&lt;li&gt;SlideTransition&lt;/li&gt;&#xA;&lt;li&gt;RotationTransition&lt;/li&gt;&#xA;&lt;li&gt;PositionedTransition&lt;/li&gt;&#xA;&lt;li&gt;DecoratedBoxTransition&lt;/li&gt;&#xA;&lt;li&gt;DefaultTextStyleTransition&lt;/li&gt;&#xA;&lt;li&gt;RelativePositionedTransition&lt;/li&gt;&#xA;&lt;li&gt;StatusTransitionWidget&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;Explicit动画的几个概念：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Animaion&amp;lt;double&amp;gt;&lt;/code&gt;：CurvedAnimation和AnimationController都继承自&lt;code&gt;Animaion&amp;lt;double&amp;gt;&lt;/code&gt;，通过Animaion可以获取动画的状态目前的插值，但是Animaion不会参与动画的绘制&lt;/li&gt;&#xA;&lt;li&gt;CurvedAnimation用于定义动画的非线性过程；AnimationController用于控制动画播放进度，需要传入TickerProvider来减少处于屏幕外的动画资源消耗；Tween用于对Animation的范围进行转化；Animation可以通过设置Listners和StatusListeners来监听动画状态。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;SingleTickerProviderStateMixin是TickerProvider的实现；mixin是线性叠加的代码继承，最后的类会覆盖前面类方法，mixin是类的一层一层叠加，类型判断可以为每一层的类，mixin更多强调的是代码的复用而不是类继承关系，mixin是一种类型不能实例化。参考：&lt;a href=&#34;https://stackoverflow.com/questions/45901297/when-to-use-mixins-and-when-to-use-interfaces-in-dart#:~:text=Mixins%20is%20all%20about%20how,that%20the%20class%20must%20satisfy.&#34;&gt;When to use mixins and when to use interfaces in Dart?&#xA;&lt;/a&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Mixins is all about how a class does what it does, it&amp;rsquo;s inheriting and sharing concrete implementation. Interfaces is all about what a class is, it is the abstract signature and promises that the class must satisfy.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android性能分析&amp;启动优化</title>
      <link>https://shenguojun.github.io/post/android-profile/</link>
      <pubDate>Tue, 19 Nov 2019 12:57:47 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-profile/</guid>
      <description>&lt;p&gt;两年前我做过了类似的启动优化分析&lt;a href=&#34;https://www.jianshu.com/p/59a2ca7df681&#34;&gt;《如何统计Android App启动时间》&lt;/a&gt;和&lt;a href=&#34;https://www.jianshu.com/p/bef74a4b6d5e&#34;&gt;《如何优化Androd App启动速度》&lt;/a&gt;。两年过后，今天看来，之前说的&lt;a href=&#34;https://link.jianshu.com/?t=https://nimbledroid.com/&#34;&gt;nimbledroid&lt;/a&gt;工具已经需要收费，而且Android Studio自带的&lt;a href=&#34;https://developer.android.com/studio/profile&#34;&gt;Android Profiler&lt;/a&gt;已经足够强大，并且&lt;a href=&#34;%5Bhttps://developer.android.com/studio/profile/systrace/command-line?utm_campaign=app_series_systracecommandline_081616%5D(https://developer.android.com/studio/profile/systrace/command-line?utm_campaign=app_series_systracecommandline_081616)&#34;&gt;Systrace&lt;/a&gt;也有了更为强大的&lt;a href=&#34;https://ui.perfetto.dev/&#34;&gt;Perfetto UI&lt;/a&gt;分析工具。我们是时候来重新学习一下目前性能分析的方法以及如何在分析的基础上做启动优化这个事情。转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>单元测试之JUnit4</title>
      <link>https://shenguojun.github.io/post/unittest/</link>
      <pubDate>Thu, 09 May 2019 12:57:47 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/unittest/</guid>
      <description>&lt;h1 id=&#34;junit4&#34;&gt;&lt;a href=&#34;https://junit.org/junit4/&#34;&gt;JUnit4&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;JUnit是一个帮助编写和执行单元测试的框架。可能很多人都接触过单元测试，但是只是停留在copy别人的测试代码再改一下的状态，下文尝试较为体系列举JUnit4中比较关键的一些知识点。转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Databinding subModule library 爬坑</title>
      <link>https://shenguojun.github.io/post/databinding-submodule/</link>
      <pubDate>Fri, 12 Apr 2019 12:57:47 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/databinding-submodule/</guid>
      <description>&lt;h1 id=&#34;问题描述&#34;&gt;问题描述&lt;/h1&gt;&#xA;&lt;p&gt;最近把gradle的‘com.android.tools.build:gradle’升级到3.2.1，升级之后dataBinding出错了，编译通过，但是运行时报了一个错误&lt;code&gt;java.lang.ClassCastException: com.youdao.dict.databinding.FragmentYdliveBindingImpl cannot be cast to com.youdao.ydliveplayer.databinding.FragmentYdliveBinding&lt;/code&gt;。转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dagger2注解大全</title>
      <link>https://shenguojun.github.io/post/dagger2-annotation/</link>
      <pubDate>Mon, 14 Jan 2019 20:00:40 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/dagger2-annotation/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;  Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍也很难消化。本文旨在通过一篇文章来让大家看懂并上手Dagger。&lt;br&gt;&#xA;  Dagger最早由&lt;a href=&#34;https://jakewharton.com/&#34;&gt;JakeWharton&lt;/a&gt;在square公司开发。后来转由Google维护并发展为Dagger2。Dagger2区别于Dagger1的地方主要在于两个，一个是由运行时通过反射构建依赖关系变为编译期通过注解生成依赖关系，另一个是出错时有更好地提醒（当然这也是因为Dagger2在编译期间根据注解生成好了可读性较好的代码带来的优势）。 转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Android create pinned shortcut创建桌面快捷方式</title>
      <link>https://shenguojun.github.io/post/android-pinned-shortcut/</link>
      <pubDate>Fri, 23 Nov 2018 20:00:40 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-pinned-shortcut/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;本文主要针对文章&lt;a href=&#34;https://developer.android.com/guide/topics/ui/shortcuts/creating-shortcuts&#34;&gt;Create shortcuts&lt;/a&gt;中动态创建桌面快捷方式的解释和例子。在8.0系统中，创建桌面快捷方式的广播&lt;code&gt;com.android.launcher.action.INSTALL_SHORTCUT&lt;/code&gt;不再生效，创建桌面快捷方式需要用另外的方法。由于文章中没有详细的例子而且表达不是很清楚，笔者也一头雾水，经过了多方的尝试，最后才明白其中的意思，希望能给同样遇到困惑的人一点帮助。转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>targetSdkVersion升级到28一些修改的地方</title>
      <link>https://shenguojun.github.io/post/android-vesrion-adaptive/</link>
      <pubDate>Fri, 16 Nov 2018 20:00:40 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-vesrion-adaptive/</guid>
      <description>&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;Android官方的迁移适配文档有点混乱，这篇文章旨在给开发者在适配中对代码做快速检查。适配变化将分为运行版本影响和Target版本影响，并提供可能影响的功能以便测试参考。转载请注明来源&lt;a href=&#34;https://www.jianshu.com/u/b692bbf77991&#34;&gt;「Bug总柴」&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kotlin精髓</title>
      <link>https://shenguojun.github.io/post/kotlin-good-part/</link>
      <pubDate>Wed, 07 Nov 2018 17:42:32 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/kotlin-good-part/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2057980-a3f52c9bfe0e692d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;引言&#34;&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;&#xA;&lt;p&gt;从谨慎地在项目中引入kotlin到全部转为kotlin开发我们用了大概半年的时间。这中间经历了从在一个小功能中尝试使用到完全使用kotlin完成了大版本开发的过程。使用方法也从仅仅地用java风格写kotlin代码，慢慢地变成使用kotlin风格去编写代码。&lt;/p&gt;</description>
    </item>
    <item>
      <title>记录一次Android Deeplink跳转失败问题修复</title>
      <link>https://shenguojun.github.io/post/android-deeplink/</link>
      <pubDate>Sat, 18 Aug 2018 12:57:47 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-deeplink/</guid>
      <description>&lt;h2 id=&#34;android-deeplink实现&#34;&gt;Android Deeplink实现&lt;/h2&gt;&#xA;&lt;p&gt;在Android中，Deeplnk通过声明Activity的intent-filter来实现对自定义url访问事件的捕捉。在有道背单词的项目中，我们需要通过前端分享词单的方式，将词单分享给别人，并通过点击前端页面收藏按钮，实现调起客户端收藏词单的功能。&lt;br&gt;&#xA;从前端通过自定义url的方式调起客户端这个功能原来一直都没有什么问题，直到最近有部分用户反馈在某些浏览器下无法调起。下面我们来看一下分析查找问题的方法以及如何解决。&lt;/p&gt;</description>
    </item>
    <item>
      <title>targetSdkVersion升级到28一些修改的地方</title>
      <link>https://shenguojun.github.io/post/targetsdkversion/</link>
      <pubDate>Wed, 18 Jul 2018 20:00:40 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/targetsdkversion/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;Google Play应用市场对于应用的targetSdkVersion有了更为严a格的要求。从 2018 年 8 月 1 日起，所有向 Google Play 首次提交的新应用都必须针对 Android 8.0 (API 等级 26) 开发； 2018 年 11 月 1 日起，所有 Google Play 的现有应用更新同样必须针对 Android 8.0。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何优化Androd App启动速度</title>
      <link>https://shenguojun.github.io/post/android-startup-speedup/</link>
      <pubDate>Tue, 03 Jul 2018 17:42:32 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-startup-speedup/</guid>
      <description>&lt;p&gt;在上一篇文章&lt;a href=&#34;http://www.jianshu.com/p/59a2ca7df681&#34;&gt;《如何统计Android App启动时间》&lt;/a&gt;中我们探讨了如何统计Android App的启动时间，以及简要分析了App启动流程。这一篇文章主要讲如何在实战中提升Android App的启动速度。下面我们先回顾一下App的启动流程。转载请注明出处：&lt;a href=&#34;http://www.jianshu.com/u/b692bbf77991&#34;&gt;Lawrence_Shen&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何统计Android App启动时间</title>
      <link>https://shenguojun.github.io/post/android-startup-time-analyze/</link>
      <pubDate>Tue, 03 Jul 2018 17:36:21 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/android-startup-time-analyze/</guid>
      <description>&lt;p&gt;随着App的逻辑不断庞大，一不注意就会将耗时的操作放置在应用启动过程之中，导致应用启动速度越来越慢，用户体验也越来越差。优化启动速度是几乎所有大型App应用开发者需要考虑的问题。优化启动速度之前首先需要准确测量App启动时间，这样有利于我们更准确可量化地看出优化效果，也可以指导我们进行持续优化。转载请注明出处：&lt;a href=&#34;http://www.jianshu.com/u/b692bbf77991&#34;&gt;Lawrence_Shen&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>第一篇发布到github的博客</title>
      <link>https://shenguojun.github.io/post/my-first-post/</link>
      <pubDate>Tue, 03 Jul 2018 10:47:20 +0800</pubDate>
      <guid>https://shenguojun.github.io/post/my-first-post/</guid>
      <description>&lt;h2 id=&#34;发一个小柴的照片记录我的第一篇博客&#34;&gt;发一个小柴的照片，记录我的第一篇博客&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://shenguojun.github.io/image/chiquan.jpg&#34; alt=&#34;chaiquan&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>About me</title>
      <link>https://shenguojun.github.io/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://shenguojun.github.io/page/about/</guid>
      <description>&lt;p&gt;I&amp;rsquo;m Lawrence(申国骏), from south China and now a senior software engineer and tech lead in Netease Youdao.&lt;/p&gt;&#xA;&lt;p&gt;Experienced in Android, J2EE and Web development, have solid knowledge in Java / Kotin and JavaScript. Compatible team player through the whole project cycle as analysis, program design, testing and implementation.&lt;/p&gt;&#xA;&lt;p&gt;Looking forward to building amazing software that can make our daily life better!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
