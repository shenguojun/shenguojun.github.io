<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Dagger2注解大全 - Lawrence&#39;s Blog</title>
  <meta name="description" content="前言 Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍">
  <meta name="author" content="申国骏"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Lawrence\u0027s Blog",
    
    "url": "https:\/\/shenguojun.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/shenguojun.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/shenguojun.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/shenguojun.github.io\/post\/dagger2-annotation\/",
          "name": "Dagger2注解大全"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "申国骏"
  },
  "headline": "Dagger2注解大全",
  "description" : "前言 Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍",
  "inLanguage" : "en",
  "wordCount":  14429 ,
  "datePublished" : "2019-01-14T20:00:40",
  "dateModified" : "2019-01-14T20:00:40",
  "image" : "https:\/\/shenguojun.github.io\/image\/bugzongchai.png",
  "keywords" : [ "android" ],
  "mainEntityOfPage" : "https:\/\/shenguojun.github.io\/post\/dagger2-annotation\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/shenguojun.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/shenguojun.github.io\/image\/bugzongchai.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Dagger2注解大全" />
<meta property="og:description" content="前言 Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍">
<meta property="og:image" content="https://shenguojun.github.io/image/bugzongchai.png" />
<meta property="og:url" content="https://shenguojun.github.io/post/dagger2-annotation/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Lawrence&#39;s Blog" />

  <meta name="twitter:title" content="Dagger2注解大全" />
  <meta name="twitter:description" content="前言 Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍">
  <meta name="twitter:image" content="https://shenguojun.github.io/image/bugzongchai.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://shenguojun.github.io/image/bugzongchai.png' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.83.1" />
  <link rel="alternate" href="https://shenguojun.github.io/index.xml" type="application/rss+xml" title="Lawrence&#39;s Blog"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://shenguojun.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://shenguojun.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://shenguojun.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-162790364-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://shenguojun.github.io/">Lawrence&#39;s Blog</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Blog" href="/">Blog</a>
            </li>
          
        
          
            <li>
              <a title="About" href="/page/about/">About</a>
            </li>
          
        
          
            <li>
              <a title="Tags" href="/tags">Tags</a>
            </li>
          
        

        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Lawrence&#39;s Blog" href="https://shenguojun.github.io/">
            <img class="avatar-img" src="https://shenguojun.github.io/image/bugzongchai.png" alt="Lawrence&#39;s Blog" />
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading text-center">
              
                <h1>Dagger2注解大全</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;Posted on January 14, 2019
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;29&nbsp;minutes
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;14429&nbsp;words
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;申国骏
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <h1>TOC</h1>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#参考">参考</a></li>
    <li><a href="#依赖注入">依赖注入</a>
      <ul>
        <li><a href="#什么是依赖注入">什么是依赖注入</a></li>
        <li><a href="#如何实现依赖注入">如何实现依赖注入</a></li>
        <li><a href="#dagger2基本概念">Dagger2基本概念</a>
          <ul>
            <li><a href="#bindings">bindings</a></li>
            <li><a href="#modules">modules</a></li>
            <li><a href="#components">components</a></li>
            <li><a href="#bindingsmodulescomponents的依赖关系图可以表示为下图所示">bindings\modules\components的依赖关系图可以表示为下图所示</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#dagger2注解">Dagger2注解</a>
      <ul>
        <li><a href="#inject">@Inject</a>
          <ul>
            <li><a href="#用于类构造器中表示该类在依赖注入时使用被注解的构造器创建对象">用于类构造器中表示该类在依赖注入时使用被注解的构造器创建对象。</a></li>
            <li><a href="#用于成员变量中表示该成员变量作为依赖需要被注入">用于成员变量中表示该成员变量作为依赖需要被注入</a></li>
            <li><a href="#用于方法中表示依赖于方法参数的类型会被注入">用于方法中表示依赖于方法参数的类型会被注入</a></li>
          </ul>
        </li>
        <li><a href="#provides---module--component">@Provides &amp;  @Module &amp; @Component</a></li>
        <li><a href="#binds">@Binds</a></li>
        <li><a href="#component">@Component</a></li>
        <li><a href="#qualifier">@Qualifier</a></li>
        <li><a href="#named">@Named</a></li>
        <li><a href="#scope和singleton">@Scope和@Singleton</a></li>
        <li><a href="#reusable">@Reusable</a></li>
        <li><a href="#component的dependencies和subcomponent">@Component的dependencies和@SubComponent</a>
          <ul>
            <li><a href="#-指定dependencies">-指定dependencies</a></li>
            <li><a href="#-subcomponent">-@SubComponent</a></li>
            <li><a href="#-指定dependencies与subcomponent区别">-指定dependencies与SubComponent区别</a></li>
          </ul>
        </li>
        <li><a href="#lazy--provider">Lazy&lt;&gt; &amp; Provider&lt;&gt;</a></li>
        <li><a href="#bindsinstance">@BindsInstance</a></li>
        <li><a href="#bindsoptionalof">@BindsOptionalOf</a></li>
        <li><a href="#mapkey">@MapKey</a></li>
        <li><a href="#multibinds">@Multibinds</a></li>
        <li><a href="#intomap--intoset--elementsintoset">@IntoMap  @IntoSet  @ElementsIntoSet</a></li>
        <li><a href="#stringkey-intkey-longkey-classkey">@StringKey @IntKey @LongKey @ClassKey</a></li>
      </ul>
    </li>
    <li><a href="#dagger2的缺点">Dagger2的缺点</a></li>
    <li><a href="#最后">最后</a></li>
    <li><a href="#例子代码下载">例子代码下载：</a></li>
  </ul>
</nav>

        <h1 id="前言">前言</h1>
<p>  Dagger是帮助实现依赖注入的库，虽然很多人都知道依赖注入对于架构设计的重要性，但是Dagger学习曲线十分陡峭，官方文档更是看了几遍也很难消化。本文旨在通过一篇文章来让大家看懂并上手Dagger。<br>
  Dagger最早由<a href="https://jakewharton.com/">JakeWharton</a>在square公司开发。后来转由Google维护并发展为Dagger2。Dagger2区别于Dagger1的地方主要在于两个，一个是由运行时通过反射构建依赖关系变为编译期通过注解生成依赖关系，另一个是出错时有更好地提醒（当然这也是因为Dagger2在编译期间根据注解生成好了可读性较好的代码带来的优势）。 转载请注明来源<a href="https://www.jianshu.com/u/b692bbf77991">「Bug总柴」</a></p>
<h1 id="参考">参考</h1>
<p>初学者建议先不要看官方文档，可以先看这几篇博客：</p>
<ul>
<li><a href="http://johnnyshieh.me/posts/dagger-basic/">Dagger 2 完全解析系列</a></li>
<li><a href="https://www.jianshu.com/p/24af4c102f62">Dagger2 最清晰的使用教程</a></li>
<li><a href="https://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-introduction-be6580cb3edb">Dagger 2 for Android Beginners系列</a></li>
</ul>
<h1 id="依赖注入">依赖注入</h1>
<p>在学习Dagger之前，我们先来了解一下依赖注入。</p>
<h2 id="什么是依赖注入">什么是依赖注入</h2>
<p>  依赖注入，顾名思义，就是说当代码执行过程中需要某个服务对象的时候，不是通过当前代码自己去构造或者去查找获取服务对象，而是通过外部将这个服务对象传给当前代码。<br>
  这样做的好处在于当服务对象构建或者获取方法改变时，不需要改变调用方的代码，这也是<a href="https://en.wikipedia.org/wiki/SOLID">S.O.L.I.D</a>原则中<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">开发封闭原则</a>的具体表现。</p>
<h2 id="如何实现依赖注入">如何实现依赖注入</h2>
<p>在不使用Dagger等依赖注入库的情况下，我们可以通过以下三种方式手动实现依赖注入。</p>
<ul>
<li>构造器依赖注入</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Constructor
</span><span class="c1"></span><span class="n">Client</span><span class="o">(</span><span class="n">Service</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Save the reference to the passed-in service inside this client
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">service</span> <span class="o">=</span> <span class="n">service</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>Setter方法依赖注入</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Setter method
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setService</span><span class="o">(</span><span class="n">Service</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Save the reference to the passed-in service inside this client.
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">service</span> <span class="o">=</span> <span class="n">service</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>接口依赖注入</li>
</ul>
<pre><code>// Service setter interface.
public interface ServiceSetter {
    public void setService(Service service);
}

// Client class
public class Client implements ServiceSetter {
    // Internal reference to the service used by this client.
    private Service service;

    // Set the service that this client is to use.
    @Override
    public void setService(Service service) {
        this.service = service;
    }
}
</code></pre><h2 id="dagger2基本概念">Dagger2基本概念</h2>
<p>Dagger2可以理解成就是在编译阶段根据注解构建一个依赖关系图，然后根据依赖关系图之间的依赖关系生成对象工厂类，在需要的地方注入对象。如何使用注解构造一个依赖关系图是Dagger2使用的关键。在了解注解之前，我们先来认识一下以下三个概念：</p>
<h3 id="bindings">bindings</h3>
<p>bindings的概念是告诉Dagger注入器如何能得到一个具体类。有几种方法可以表示当前代码可以提供某个类型的对象：</p>
<ul>
<li>通过使用<code>@Provides</code>注解的非抽象方法返回一个类对象</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Provides</span>
<span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">providerApple</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>通过<code>@Binds</code>注解的抽象方法，该抽象方法返回接口或抽象类，参数是一个该接口或者抽象类的具体实现类</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Binds</span>
<span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindApple</span><span class="o">(</span><span class="n">Apple</span> <span class="n">apple</span><span class="o">);</span>
</code></pre></div><ul>
<li>通过<code>@Inject</code>注解的构造方法</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Apple</span> <span class="kd">implements</span> <span class="n">Fruit</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">Apple</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul>
<li>通过<code>multibindings</code>（<code>@MapKey</code>后面提到）或者<code>producers</code>（暂不细说）提供</li>
</ul>
<h3 id="modules">modules</h3>
<p>module是一个只有<code>@Provides</code>和<code>@Binds</code>方法的类，用于集合所有的依赖关系。同时module可以通过<code>inculdes</code>来引入其他module从而得到其他module的依赖关系集合。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span><span class="o">(</span><span class="n">includes</span> <span class="o">=</span> <span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>
    <span class="nd">@Binds</span> 
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindApple</span><span class="o">(</span><span class="n">Apple</span> <span class="n">apple</span><span class="o">);</span>

    <span class="nd">@Provides</span>
    <span class="kd">static</span> <span class="n">Desk</span> <span class="nf">provideDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="components">components</h3>
<p><code>component</code>是被<code>@Component</code>标注的接口或者抽象类，Dagger会负责实例化一个<code>component</code>。<code>component</code>中指定需要的<code>modules</code>，代表着这次依赖构建所有需要的全部依赖关系都可以从<code>modules</code>中找到。<code>compoent</code>中的方法只能是无参的，且这个无参方法的返回值就是Dagger最终需要构建得到的实体。<strong>可以说构建<code>component</code>中无参方法的返回值对象就是整个依赖关系查找的起源点</strong>。在构建这个实体时，如果遇到依赖，就会从<code>modules</code>中不断地传递查找，直到所有的依赖都被找到为止。如果中间有某些依赖没有注明实例化方式，Dagger会在编译期间报错。具体<code>component</code>的一个例子如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><h3 id="bindingsmodulescomponents的依赖关系图可以表示为下图所示">bindings\modules\components的依赖关系图可以表示为下图所示</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/2057980-45abc423e8a37514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dagger依赖图.png"></p>
<h1 id="dagger2注解">Dagger2注解</h1>
<p>知道上面的概念可以看懂基本的Dagger代码。不过Dagger有非常多帮助完成依赖关系图构建的注解，只有把这些注解都弄懂了，才能真正看懂Dagger2的代码。下面两个图可以看到一些常用的注解：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2057980-642ae0a8be862ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="javax.inject.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2057980-83c3d2cb425b1fec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dagger.png"></p>
<p>下面我们来一一介绍一下。</p>
<h2 id="inject">@Inject</h2>
<p><code>@Inject</code>是<code>javax.inject</code>包中的注解，可以用于对类的<strong>构造函数</strong>、<strong>成员变量</strong>和<strong>方法</strong>。</p>
<h3 id="用于类构造器中表示该类在依赖注入时使用被注解的构造器创建对象">用于类构造器中表示该类在依赖注入时使用被注解的构造器创建对象。</h3>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>表示当其他地方依赖于<code>FruitShop</code>对象时，会使用FruitShop的默认构造方法进行创建。当被<code>@Inject</code>注解的构造函数是有参数的，那么Dagger会同时对其参数进行注入。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">(</span><span class="n">Desk</span> <span class="n">desk</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>当需要构建依赖关系时，在创建FruitShop的时候回对参数<code>desk</code>进行注入。<br>
在生成的<code>FruitShop_Factory.java</code>代码中，可以看到以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitShop_Factory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">FruitShop</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">FruitShop_Factory</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">deskProvider</span> <span class="o">=</span> <span class="n">deskProvider</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">FruitShop</span> <span class="nf">provideInstance</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FruitShop</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitShop</span><span class="o">(</span><span class="n">deskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>@Inject</code>用于构造函数需要注意两点：</p>
<ol>
<li>每个类只允许一个构造方法注解为<code>@Inject</code>，例如</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="c1">// 由于有另外的构造函数注解了@Inject，这里不能再使用@Inject，否则编译会出错Error: Types may only contain one @Inject constructor.
</span><span class="c1"></span>    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">(</span><span class="n">Location</span> <span class="n">location</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ol start="2">
<li><code>javax.inject.Inject</code>文档中说明当被注解的构造函数是public且无参的默认构造函数<code>@Inject</code>可以省略。但是实际Dagger2项目中，需要被注入的对象必须拥有<code>@Inject</code>注解的构造方法或者通过<code>@Porvides</code>注解的方法提供，否则会报错<code>Error: cannot be provided without an @Inject constructor or an @Provides-annotated method.</code>。这一点Dagger的处理与<code>javax.inject.Inject</code>描述表现不一致。</li>
</ol>
<h3 id="用于成员变量中表示该成员变量作为依赖需要被注入">用于成员变量中表示该成员变量作为依赖需要被注入</h3>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">Fruit</span> <span class="n">apple</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>表示<code>FruitShop</code>中需要依赖水果<code>apple</code>，并希望由外部注入进来。
编译之后我们会看到一个<code>FruitShop_MembersInjector.java</code>的类，里面会有一个这样的方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitShop_MembersInjector</span> <span class="kd">implements</span> <span class="n">MembersInjector</span><span class="o">&lt;</span><span class="n">FruitShop</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// Dagger生成代码中会通过MembersInjector给我们对象需要的属性进行注入
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">injectApple</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">,</span> <span class="n">Fruit</span> <span class="n">apple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instance</span><span class="o">.</span><span class="na">apple</span> <span class="o">=</span> <span class="n">apple</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>对于属性注解需要注意被注解的属性不能是<code>final</code>或者被<code>private</code>修饰符修饰。其中的原因在上面<code>instance.apple = apple;</code>代码中不言而喻。<br>
在生成的<code>FruitShop_Factory.java</code>代码中，可以看到以下方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitShop_Factory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">FruitShop</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">FruitShop_Factory</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">appleProvider</span> <span class="o">=</span> <span class="n">appleProvider</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">FruitShop</span> <span class="nf">provideInstance</span><span class="o">(</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FruitShop</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitShop</span><span class="o">();</span>
        <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectApple</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">appleProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="用于方法中表示依赖于方法参数的类型会被注入">用于方法中表示依赖于方法参数的类型会被注入</h3>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="n">Desk</span> <span class="n">mDesk</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDesk</span><span class="o">(</span><span class="n">Desk</span> <span class="n">desk</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mDesk</span> <span class="o">=</span> <span class="n">desk</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>被注解的<code>setDesk()</code>方法有一个<code>Desk</code>类型的参数，意味着需要对<code>Desk</code>进行依赖注入。Dagger生成的代码如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitShop_Factory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">FruitShop</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">FruitShop_Factory</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">deskProvider</span> <span class="o">=</span> <span class="n">deskProvider</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">FruitShop</span> <span class="nf">provideInstance</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Desk</span><span class="o">&gt;</span> <span class="n">deskProvider</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FruitShop</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FruitShop</span><span class="o">();</span>
        <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectSetDesk</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">deskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitShop_MembersInjector</span> <span class="kd">implements</span> <span class="n">MembersInjector</span><span class="o">&lt;</span><span class="n">FruitShop</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">injectSetDesk</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">,</span> <span class="n">Desk</span> <span class="n">desk</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instance</span><span class="o">.</span><span class="na">setDesk</span><span class="o">(</span><span class="n">desk</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>@Inject</code>用于注解方法需要注意被注解的方法不能是<code>private</code>的。被注解的方法支持拥有多个参数。如果标注在public方法上，Dagger2会在构造方法执行之后立即调用这个方法。</p>
<h2 id="provides---module--component">@Provides &amp;  @Module &amp; @Component</h2>
<p>使用<code>@Inject</code>来标记依赖的注入不是什么时候都可以的，例如第三方api的代码我们是不能修改的，没办法通过<code>@Inject</code>注解第三方api类的构造器，从而没办法对第三方api的对象进行构建和依赖注入。这个时候我们可以使用<code>@Provides</code>来提供对应的依赖。而<code>@Provides</code>必须放到一个被<code>@Module</code>注解的类中。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 通过在module中使用@Provides表示提供依赖的方法
</span><span class="c1"></span><span class="nd">@Module</span>
<span class="kd">public</span>  <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>
    <span class="nd">@Provides</span>
    <span class="n">Fruit</span> <span class="nf">provideApple</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 使用@Inject说明需要依赖注入的地方
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="c1">// 这里需要提供一个Fruit类型的依赖
</span><span class="c1"></span>    <span class="nd">@Inject</span>
    <span class="n">Fruit</span> <span class="n">apple</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 将需要用到依赖的地方FruitShop和提供依赖的地方FruitModule绑定在一起
</span><span class="c1"></span><span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>这里在module中声明了一个可以提供<code>Apple</code>类依赖的方法<code>provideApple()</code>。并且component将依赖的需求方和提供方都绑定在了一起。我们来看生成的代码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FruitModule_ProvideAppleFactory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">FruitModule</span> <span class="n">module</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">FruitModule_ProvideAppleFactory</span><span class="o">(</span><span class="n">FruitModule</span> <span class="n">module</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">module</span> <span class="o">=</span> <span class="n">module</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">provideInstance</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Fruit</span> <span class="nf">provideInstance</span><span class="o">(</span><span class="n">FruitModule</span> <span class="n">module</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">proxyProvideApple</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">FruitModule_ProvideAppleFactory</span> <span class="nf">create</span><span class="o">(</span><span class="n">FruitModule</span> <span class="n">module</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">FruitModule_ProvideAppleFactory</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Fruit</span> <span class="nf">proxyProvideApple</span><span class="o">(</span><span class="n">FruitModule</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span>
        <span class="n">instance</span><span class="o">.</span><span class="na">provideApple</span><span class="o">(),</span> <span class="s">&#34;Cannot return null from a non-@Nullable @Provides method&#34;</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>这段生成的代码实际上是提供<code>Apple</code>类工厂<code>FruitModule_ProvideAppleFactory</code>，能够通过<code>provideApple()</code>提供<code>Apple</code>对象。以下的代码中，component通过传递<code>FruitModule_ProvideAppleFactory</code>对象到<code>FruitShop_Factory</code>中完成对<code>FruitShop</code>的依赖注入</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">FruitModule_ProvideAppleFactory</span> <span class="n">provideAppleProvider</span><span class="o">;</span>
  
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">provideAppleProvider</span> <span class="o">=</span> <span class="n">FruitModule_ProvideAppleFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">fruitModule</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">fruitShopProvider</span> <span class="o">=</span> <span class="n">DoubleCheck</span><span class="o">.</span><span class="na">provider</span><span class="o">(</span><span class="n">FruitShop_Factory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">provideAppleProvider</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>通过<code>@Provides</code> <code>@Module</code> <code>@Component</code> 三个注解就可以完成最基本的依赖注入关系图的构造，从而使用Dagger给依赖进行注入。这里需要注意：</p>
<ul>
<li>通过<code>@Provides</code>注解的方法不能返回null，否则会报<code>NullPointerException</code>。如果<code>@Provides</code>方法可能返回null，那需要加上注入<code>@Nullable</code>，同时在需要依赖注入的地方加上<code>@Nullable</code>标注。</li>
<li>一般module类都使用XXXModule命名，而provide方法一般都使用provideXXX命名方式。</li>
</ul>
<h2 id="binds">@Binds</h2>
<p><code>@Binds</code>的作用和<code>@Provides</code>的作用是一样的，是提供接口依赖的一种简洁表示的方式。例如下面这个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span>  <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>
    <span class="nd">@Provides</span>
    <span class="n">Fruit</span> <span class="nf">provideApple</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Apple</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>使用<code>@Binds</code>可以简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">abstract</span> <span class="kd">public</span>  <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>
    <span class="nd">@Binds</span>
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindApple</span><span class="o">(</span><span class="n">Apple</span> <span class="n">apple</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>表示当需要依赖<code>Furit</code>接口时，使用<code>Apple</code>实例对象进行注入。需要注意的是，使用<code>@Binds</code>标注的方法必须有且仅有一个方法参数，且这个方法参数是方法返回值的实现类或者子类。</p>
<h2 id="component">@Component</h2>
<p>因为Componet较为复杂，拿出来再单独说一下。Component的声明如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Component</span> <span class="o">{</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">modules</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>
    <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">dependencies</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>
    <span class="nd">@interface</span> <span class="n">Builder</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div><p>这代表着<code>@Component</code>的标签中除了可以指定modules之外还可以通过dependencies引用其他的component。在被<code>@Component</code>注解的类必须是接口或者抽象类，这个被注解的类中可以包含以下三个东西：</p>
<ol>
<li>表示需要提供的依赖的方法，例如：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 表示需要注入依赖生成SomeType类对象
</span><span class="c1"></span><span class="n">SomeType</span> <span class="nf">getSomeType</span><span class="o">();</span>
<span class="c1">// 表示需要注入依赖生成Set&lt;SomeType&gt;对象，multibinding后面会介绍
</span><span class="c1"></span><span class="n">Set</span><span class="o">&lt;</span><span class="n">SomeType</span><span class="o">&gt;</span> <span class="nf">getSomeTypes</span><span class="o">();</span>
<span class="c1">// 表示需要注入生成一个Qualifier为PortNumber的int整形，Qualifier后面会介绍
</span><span class="c1"></span><span class="nd">@PortNumber</span> <span class="kt">int</span> <span class="nf">getPortNumber</span><span class="o">();</span>
<span class="c1">// 表示需要注入依赖生成Provider&lt;SomeType&gt;对象，Provider&lt;&gt;后面介绍
</span><span class="c1"></span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">SomeType</span><span class="o">&gt;</span> <span class="nf">getSomeTypeProvider</span><span class="o">();</span>
<span class="c1">// 表示需要注入依赖生成Lazy&lt;SomeType&gt;对象，Lazy&lt;&gt;后面会介绍
</span><span class="c1"></span><span class="n">Lazy</span><span class="o">&lt;</span><span class="n">SomeType</span><span class="o">&gt;</span> <span class="nf">getLazySomeType</span><span class="o">();</span>
</code></pre></div><ol start="2">
<li>表示需要注入成员依赖的方法,</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 表示需要将someType中标记为依赖的属性和方法进行注入
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">injectSomeType</span><span class="o">(</span><span class="n">SomeType</span> <span class="n">someType</span><span class="o">);</span>
<span class="c1">// 表示需要将someType中标记为依赖的属性和方法进行注入，并返回SomeType对象
</span><span class="c1"></span><span class="n">SomeType</span> <span class="nf">injectAndReturnSomeType</span><span class="o">(</span><span class="n">SomeType</span> <span class="n">someType</span><span class="o">);</span>
</code></pre></div><ol start="3">
<li>构造Component的Builder<br>
Dagger生成Component实现类时，会自动根据Bulder模式生成所需要Builder类。当Component所依赖的Module为非抽象且默认构造函数为private时，则Dagger会生成对应的有传入module方法的Builder类，例如：</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Desk</span> <span class="n">mDesk</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">ProjectModule</span><span class="o">(){}</span>
    
    <span class="kd">public</span> <span class="nf">ProjectModule</span><span class="o">(</span><span class="n">Desk</span> <span class="n">desk</span><span class="o">){</span>
        <span class="n">mDesk</span> <span class="o">=</span> <span class="n">desk</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="nd">@Provides</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provide</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mDesk</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>则在生成的DaggerFruitComponent中会有以下Builder方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">ProjectModule</span> <span class="n">projectModule</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ProjectModule</span> <span class="n">projectModule</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Builder</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="n">FruitComponent</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">projectModule</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getCanonicalName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; must be set&#34;</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">DaggerFruitComponent</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">projectModule</span><span class="o">(</span><span class="n">ProjectModule</span> <span class="n">projectModule</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">projectModule</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">projectModule</span><span class="o">);</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在调用时需要传入依赖的module：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">FruitShop</span> <span class="n">fruitShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span>
                    <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">projectModule</span><span class="o">(</span><span class="k">new</span> <span class="n">ProjectModule</span><span class="o">(</span><span class="k">new</span> <span class="n">Desk</span><span class="o">()))</span>
                    <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
</code></pre></div><p>当Component所依赖的module和其他Componet都不需要使用有参的构造函数的话，Component可以使用简洁的<code>create()</code>方法，例如将上面的module改为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>
    
    <span class="nd">@Provides</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provide</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>则生成的componet会是这样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">FruitComponent</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Builder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ProjectModule</span> <span class="n">projectModule</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Builder</span><span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="n">FruitComponent</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">projectModule</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">projectModule</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProjectModule</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">DaggerFruitComponent</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">projectModule</span><span class="o">(</span><span class="n">ProjectModule</span> <span class="n">projectModule</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">projectModule</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">projectModule</span><span class="o">);</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在调用时仅需调用<code>create()</code>方法既可</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">FruitShop</span> <span class="n">fruitShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span><span class="o">.</span><span class="na">create</span><span class="o">().</span><span class="na">inject</span><span class="o">();</span>
</code></pre></div><h2 id="qualifier">@Qualifier</h2>
<p>在上面了解完<code>@Inject</code>之后，大家可能有个疑惑，使用<code>@Inject</code>注入的对象如果是接口或者抽象类怎么办呢？在不同的地方可能需要不同的接口或者抽象类的实现，怎么让Dagger知道我究竟需要的哪种实现类呢？例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">Fruit</span> <span class="n">apple</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">Fruit</span> <span class="n">orange</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>  这里代码需要对<code>apple</code>和<code>orange</code>进行注入，但是对于<code>Fruit</code>的注入只能声明一个，所以这个地方<code>apple</code>和<code>orange</code>要么都被注入成<code>class Apple implements Fruit</code>或者<code>class Orange implements Fruit</code>。<br>
  <code>@Qualifier</code>这个时候就能作为一个限定符派上用场了。<code>@Qualifier</code>是加在注解之上的注解（也称为元注解），当需要注入的是接口或者抽象类，就可以使用<code>@Qualifier</code>来定义一个新的注解用来表明对应需要的依赖关系。使用<code>@Qualifier</code>可以实现指定<code>apple</code>需要用<code>Apple</code>注入，<code>orange</code>需要使用<code>Orange</code>类注入。例如我们可以这样实现</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 首先定义一个表示水果类型的注解
</span><span class="c1"></span><span class="nd">@Qualifier</span>
<span class="nd">@Documented</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">FruitType</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 接着使用这个注解表示对应依赖关系
</span><span class="c1"></span><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>
    <span class="nd">@Binds</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span>
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindApple</span><span class="o">(</span><span class="n">Apple</span> <span class="n">apple</span><span class="o">);</span>

    <span class="nd">@Binds</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;orange&#34;</span><span class="o">)</span>
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindOrange</span><span class="o">(</span><span class="n">Orange</span> <span class="n">orange</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 使用时标记相应的注解既可
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span>
    <span class="n">Fruit</span> <span class="n">apple</span><span class="o">;</span>

    <span class="nd">@Inject</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;orange&#34;</span><span class="o">)</span>
    <span class="n">Fruit</span> <span class="n">orange</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>除了可以声明value为String的注解外，还可以传入其他类型，例如我们需要一张颜色是红色的桌子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@java.lang.annotation.Documented</span>
<span class="nd">@java.lang.annotation.Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
<span class="nd">@javax.inject.Qualifier</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">DeskColor</span> <span class="o">{</span>
    <span class="n">Color</span> <span class="nf">color</span><span class="o">()</span> <span class="k">default</span> <span class="n">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">enum</span> <span class="n">Color</span> <span class="o">{</span> <span class="n">RED</span><span class="o">,</span> <span class="n">WHITE</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在Module中可以指定具体生成的对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span> <span class="nd">@DeskColor</span><span class="o">(</span><span class="n">color</span> <span class="o">=</span> <span class="n">DeskColor</span><span class="o">.</span><span class="na">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provideDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">(</span><span class="s">&#34;RED&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在使用时再进行标记既可：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Inject</span> <span class="nd">@DeskColor</span><span class="o">(</span><span class="n">color</span> <span class="o">=</span> <span class="n">DeskColor</span><span class="o">.</span><span class="na">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">)</span>
    <span class="n">Desk</span> <span class="n">desk</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>通过<code>@Qualifier</code>定义注解可以实现对同一个接口或抽象类的指定不同对象注入。</p>
<h2 id="named">@Named</h2>
<p>了解完<code>@Qualifier</code>之后再看看<code>@Name</code>的声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Qualifier</span>
<span class="nd">@Documented</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Named</span> <span class="o">{</span>

    <span class="cm">/** The name. */</span>
    <span class="n">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>可以看出除了接口名称不一样之外，其余的和上面定义的<code>@FruitType</code>是一致的，所以其实<code>@Named</code>只是系统定义好的，参数为String的默认限定符。将上面代码中的<code>@FruitType</code>改成<code>@Named</code>能达到一样的效果。</p>
<h2 id="scope和singleton">@Scope和@Singleton</h2>
<p><code>@Scope</code>是另一个元注解，它的作用是告诉注入器要注意对象的重用的生命周期。其中<code>@Scope</code>的声明如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ANNOTATION_TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
<span class="nd">@Documented</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Scope</span> <span class="o">{}</span>
</code></pre></div><p>我们再看<code>@Singleton</code>的声明：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Scope</span>
<span class="nd">@Documented</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Singleton</span> <span class="o">{}</span>
</code></pre></div><p>可以发现<code>@Singleton</code>就是被<code>@Scope</code>声明的注解，可以作为一个生命周期的注解符。<br>
例如我们需要注入一个<code>Desk</code>类，我们希望一个<code>FruitShop</code>对应只有一个<code>Desk</code>，正常的情况下我们是这样声明的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Injec</span>
    <span class="n">Desk</span> <span class="n">desk</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">Desk</span> <span class="n">desk2</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">checkDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">desk</span> <span class="o">==</span> <span class="n">desk2</span> <span class="o">?</span> <span class="s">&#34;desk equal&#34;</span> <span class="o">:</span> <span class="s">&#34;desk not equal&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provideDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>在Main函数中执行</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FruitShop</span> <span class="n">fruitShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span><span class="o">.</span><span class="na">create</span><span class="o">().</span><span class="na">inject</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fruitShop</span><span class="o">.</span><span class="na">checkDesk</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>得到的结果是</p>
<blockquote>
<p>desk not equal</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>当然这不是我们希望得到的结果，下面我们来用<code>@Singleton</code>改造一下如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Injec</span>
    <span class="n">Desk</span> <span class="n">desk</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">Desk</span> <span class="n">desk2</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">checkDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">desk</span> <span class="o">==</span> <span class="n">desk2</span> <span class="o">?</span> <span class="s">&#34;desk equal&#34;</span> <span class="o">:</span> <span class="s">&#34;desk not equal&#34;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span>
    <span class="nd">@Singleton</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provideDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>现在Rebuild之后再运行一下：</p>
<blockquote>
<p>desk equal</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>和之前不同的地方在于我们队Component和module中的provide方法都加了<code>@Singleton</code>标记。我们来看看对比下前后生成的代码有什么区别：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2057980-480379ecf6e735e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="diff.png"></p>
<p>可以看出，两次生成的代码中，只有<code>DaggerFruitComponent</code>有区别，其中的区别在于在Component中<code>provideDeskProvider</code>在有<code>@Singleton</code>标注的例子中是单例的存在：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// DoubleCheck.provider就是用了双重检验的单例模式提供单例
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">provideDeskProvider</span> <span class="o">=</span>
        <span class="n">DoubleCheck</span><span class="o">.</span><span class="na">provider</span><span class="o">(</span><span class="n">ProjectModule_ProvideDeskFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">projectModule</span><span class="o">));</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="n">FruitShop</span> <span class="nf">injectFruitShop</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">provideDeskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk2</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">provideDeskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div><p>其中<code>DoubleCheck.get()</code>方法使用双重判断获取单例。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DoubleCheck</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;,</span> <span class="n">Lazy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">UNINITIALIZED</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">UNINITIALIZED</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
          <span class="n">instance</span> <span class="o">=</span> <span class="n">reentrantCheck</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
          <span class="cm">/* Null out the reference to the provider. We are never going to need it again, so we
</span><span class="cm">           * can make it eligible for GC. */</span>
          <span class="n">provider</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>而在没有使用<code>@Singletion</code>的例子中，并没有使用单例来提供<code>Desk</code>对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java">  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">projectModule</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">projectModule</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">private</span> <span class="n">FruitShop</span> <span class="nf">injectFruitShop</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk</span><span class="o">(</span>
        <span class="n">instance</span><span class="o">,</span> <span class="n">ProjectModule_ProvideDeskFactory</span><span class="o">.</span><span class="na">proxyProvideDesk</span><span class="o">(</span><span class="n">projectModule</span><span class="o">));</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk2</span><span class="o">(</span>
        <span class="n">instance</span><span class="o">,</span> <span class="n">ProjectModule_ProvideDeskFactory</span><span class="o">.</span><span class="na">proxyProvideDesk</span><span class="o">(</span><span class="n">projectModule</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div><p>通过上面的例子可以看出<code>@Scope</code>是用来定义需要的依赖对象在一个Component依赖关系图生成中是否需要重用，且重用的范围在一个Component对象的引用范围内。至于<code>@Scope</code>的意义在于可以在Components之间的依赖中使得依赖对象在不同的Components中重用。Components之间的依赖会在后面介绍。</p>
<p>这里需要注意几点：</p>
<ol>
<li><code>@Scope</code>注解的注解不能用于标注依赖的构造函数</li>
<li>没有被<code>@Scope</code>注解的注解（如<code>@Singleton</code>）注解的componet不能存在被<code>@Scope</code>注解的注解（如<code>@Singleton</code>）注解的方法（有点绕，可以理解成没有标志为<code>@Singleton</code>的componet不能拥有标志为<code>@Singleton</code>的方法）</li>
<li>如果componet定义了一个scope，那么这个componet里面只能存在没有scoped的依赖关系，或者拥有跟componet一样scope的依赖关系</li>
<li>使用Componet的调用方需要负责重用范围的定义，例如希望有一个全局的单例，那么则需要保存一个拥有全局生命周期的component依赖生成类对象。</li>
</ol>
<h2 id="reusable">@Reusable</h2>
<p>与<code>@Singleton</code>类似的，<code>@Reusable</code>也是被<code>@Scope</code>注释的注释。与<code>@Singleton</code>不同的是，<code>@Reusable</code>只表示Dagger生成的对象可以被缓存起来，从而节省内存消耗，但是不能保证对象的单例性质。我们将上面例子中的<code>@Singleton</code>改成<code>@Reusable</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span>
    <span class="nd">@Reusable</span>
    <span class="kd">public</span> <span class="n">Desk</span> <span class="nf">provideDesk</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Desk</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>rebuild之后我们来看生成的代码</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">provideDeskProvider</span> <span class="o">=</span>
        <span class="n">SingleCheck</span><span class="o">.</span><span class="na">provider</span><span class="o">(</span><span class="n">ProjectModule_ProvideDeskFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">projectModule</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="kd">private</span> <span class="n">FruitShop</span> <span class="nf">injectFruitShop</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">provideDeskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectDesk2</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">provideDeskProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>其中<code>SingleCheck.get()</code>方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SingleCheck</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">T</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Object</span> <span class="n">local</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">local</span> <span class="o">==</span> <span class="n">UNINITIALIZED</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// provider is volatile and might become null after the check, so retrieve the provider first
</span><span class="c1"></span>      <span class="n">Provider</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">providerReference</span> <span class="o">=</span> <span class="n">provider</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">providerReference</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// The provider was null, so the instance must already be set
</span><span class="c1"></span>        <span class="n">local</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">local</span> <span class="o">=</span> <span class="n">providerReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">local</span><span class="o">;</span>

        <span class="c1">// Null out the reference to the provider. We are never going to need it again, so we can
</span><span class="c1"></span>        <span class="c1">// make it eligible for GC.
</span><span class="c1"></span>        <span class="n">provider</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">T</span><span class="o">)</span> <span class="n">local</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>与刚刚的区别是由<code>DoubleCheck.provider</code>变成了<code>SingleCheck.provider</code>，从代码实现可以看出<code>@Reusable</code>并不是严格的单例模式，只是对对象进行了缓存。</p>
<h2 id="component的dependencies和subcomponent">@Component的dependencies和@SubComponent</h2>
<p>虽然独立的没有scope范围的component已经非常实用了，但是在某些情况可能需要用到多个不同scope的不同componet。不同的Component之间可以通过指定依赖关系来联系起来。Components之间的关联可以采取两种方式：指定指定dependencies或者SubComponet。下面我们来看看二者的区别。</p>
<h3 id="-指定dependencies">-指定dependencies</h3>
<p>当一个Component需要从另一个Componet中获得依赖的时候，可以使用<code>@Component(dependencies = {XXXComponent.class})</code>来引用其他component的依赖。需要注意的是，被引用的Component需要显示暴露出给外部的依赖，不然编译会报错。看下面这个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>

    <span class="c1">// 对外暴露的依赖，表示其他Component可以从这个Component中
</span><span class="c1"></span>    <span class="c1">// 获得@FruitType为apple的类型为Fruit的依赖
</span><span class="c1"></span>    <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span>
    <span class="n">Fruit</span> <span class="nf">getApple</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>在有了水果的依赖之后，我们创建一个果汁的依赖关系：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Juice</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">name</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppleJuice</span> <span class="kd">implements</span> <span class="n">Juice</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">Fruit</span> <span class="n">mApple</span><span class="o">;</span>

    <span class="c1">// 这里要构建一个苹果汁，需要用到苹果，这个依赖需要从FruitComponent中获得
</span><span class="c1"></span>    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">AppleJuice</span><span class="o">(</span><span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span> <span class="n">Fruit</span> <span class="n">apple</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mApple</span> <span class="o">=</span> <span class="n">apple</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">name</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mApple</span><span class="o">.</span><span class="na">name</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Module</span>
<span class="kd">abstract</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">JuiceModule</span> <span class="o">{</span>

    <span class="nd">@OtherScop</span>
    <span class="nd">@Binds</span> <span class="nd">@JuiceType</span><span class="o">(</span><span class="s">&#34;appleJuice&#34;</span><span class="o">)</span>
    <span class="kd">abstract</span> <span class="n">Juice</span> <span class="nf">bindAppleJuice</span><span class="o">(</span><span class="n">AppleJuice</span> <span class="n">appleJuice</span><span class="o">);</span>

<span class="o">}</span>

<span class="c1">// 这里通过指定dependencies，指出JuiceComponent需要FruitComponent作为依赖
</span><span class="c1"></span><span class="nd">@OtherScop</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">dependencies</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitComponent</span><span class="o">.</span><span class="na">class</span><span class="o">},</span> <span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">JuiceModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JuiceComponent</span> <span class="o">{</span>
    <span class="n">JuiceShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JuiceShop</span> <span class="o">{</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">JuiceShop</span><span class="o">(){}</span>

    <span class="c1">// 构建果汁商店需要一个苹果汁，Dagger将负责构建
</span><span class="c1"></span>    <span class="nd">@Inject</span>
    <span class="nd">@JuiceType</span><span class="o">(</span><span class="s">&#34;appleJuice&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Juice</span> <span class="n">appleJuice</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getJuice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">appleJuice</span><span class="o">.</span><span class="na">name</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>上面的代码，关注<code>JuiceComponent</code>类，这个类本身依赖关系图从<code>JuiceModule</code>中获得，而<code>JuiceModule</code>类只是声明了<code>JuiceType</code>为<code>appleJuice</code>的<code>Juice</code>类通过创建<code>AppleJuice</code>获得。而观察<code>AppleJuice</code>类需要一个<code>FruitType</code>为<code>apple</code>的<code>Fruit</code>类作为依赖。这个<code>Fruit</code>类的依赖并不能从<code>JuiceComponent</code>中获得，因此我们指定拥有这个<code>Fruit</code>类依赖的<code>dependencies = {FruitComponent.class}</code>。在<code>FruitComponent</code>类中需要显示声明其可以提供<code>FruitType</code>为<code>apple</code>的<code>Fruit</code>类如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span>
<span class="n">Fruit</span> <span class="nf">getApple</span><span class="o">();</span>
</code></pre></div><p>因此通过指定<code>dependencies = {FruitComponent.class}</code>构成了完整的依赖关系链，我们可以如下构建一个<code>JuiceShop</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">DaggerJuiceComponent</span>
            <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
            <span class="o">.</span><span class="na">fruitComponent</span><span class="o">(</span><span class="n">DaggerFruitComponent</span><span class="o">.</span><span class="na">create</span><span class="o">())</span>
            <span class="o">.</span><span class="na">build</span><span class="o">()</span>
            <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">juiceShop</span><span class="o">.</span><span class="na">getJuice</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><p>Dagger会给我们生成<code>DaggerJuiceComponent</code>，并通过<code>fruitComponent()</code>方法，放入<code>DaggerFruitComponent</code>的依赖。我们来看看Dagger生成的<code>DaggerJuiceComponent</code>具体是如何使用<code>DaggerFruitComponent</code>来生成依赖的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerJuiceComponent</span> <span class="kd">implements</span> <span class="n">JuiceComponent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">com_shen_example_di_FruitComponent_getApple</span> <span class="n">getAppleProvider</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nf">DaggerJuiceComponent</span><span class="o">(</span><span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">initialize</span><span class="o">(</span><span class="n">builder</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 保存fruitComponent到com_shen_example_di_FruitComponent_getApple内部类中
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">getAppleProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">com_shen_example_di_FruitComponent_getApple</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">fruitComponent</span><span class="o">);</span>
        <span class="c1">// 将保存有fruitComponent的内部类传递给AppleJuice构造工厂
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">appleJuiceProvider</span> <span class="o">=</span> <span class="n">AppleJuice_Factory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">getAppleProvider</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">com_shen_example_di_FruitComponent_getApple</span> <span class="kd">implements</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">FruitComponent</span> <span class="n">fruitComponent</span><span class="o">;</span>

        <span class="n">com_shen_example_di_FruitComponent_getApple</span><span class="o">(</span><span class="n">FruitComponent</span> <span class="n">fruitComponent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fruitComponent</span> <span class="o">=</span> <span class="n">fruitComponent</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 通过fruitComponent创建apple
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span>
            <span class="n">fruitComponent</span><span class="o">.</span><span class="na">getApple</span><span class="o">(),</span> <span class="s">&#34;Cannot return null from a non-@Nullable component method&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Builder</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">FruitComponent</span> <span class="n">fruitComponent</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">JuiceComponent</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">DaggerJuiceComponent</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">Builder</span> <span class="nf">fruitComponent</span><span class="o">(</span><span class="n">FruitComponent</span> <span class="n">fruitComponent</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">fruitComponent</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">fruitComponent</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">AppleJuice_Factory</span> <span class="kd">implements</span> <span class="n">Factory</span><span class="o">&lt;</span><span class="n">AppleJuice</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">AppleJuice_Factory</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">appleProvider</span> <span class="o">=</span> <span class="n">appleProvider</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">AppleJuice</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">provideInstance</span><span class="o">(</span><span class="n">appleProvider</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">AppleJuice</span> <span class="nf">provideInstance</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 最终通过调用保存有fruitComponent的get方法，
</span><span class="c1"></span>    <span class="c1">// 通过fruitComponent创建apple，并传入给AppleJuice构造函数中
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="n">AppleJuice</span><span class="o">(</span><span class="n">appleProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="n">AppleJuice_Factory</span> <span class="nf">create</span><span class="o">(</span><span class="n">Provider</span><span class="o">&lt;</span><span class="n">Fruit</span><span class="o">&gt;</span> <span class="n">appleProvider</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">AppleJuice_Factory</span><span class="o">(</span><span class="n">appleProvider</span><span class="o">);</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>通过上述Dagger生成的代码可以看出，通过dependencies方式指定Component依赖，Dagger会将依赖的Component通过组合方式传入给目标的Component，并在目标Component需要创建依赖时，通过组合传入的依赖Component进行依赖类的构建。再次强调，如果没有在依赖Component中声明其对外暴露的依赖，会出现报错。例如假设我们将上面的<code>FruitComponent</code>去掉<code>getApple</code>方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>那么在编译时会出现报错：</p>
<pre><code>Error:(8, 8) java: [Dagger/MissingBinding] @com.shen.example.di.FruitType(&quot;apple&quot;) com.shen.example.fruit.Fruit cannot be provided without an @Provides-annotated method.
      @com.shen.example.di.FruitType(&quot;apple&quot;) com.shen.example.fruit.Fruit is injected at
          com.shen.example.juice.AppleJuice(apple)
      com.shen.example.juice.AppleJuice is injected at
          com.shen.example.di.JuiceModule.bindAppleJuice(appleJuice)
      @com.shen.example.di.JuiceType(&quot;appleJuice&quot;) com.shen.example.juice.Juice is injected at
          com.shen.example.JuiceShop.appleJuice
      com.shen.example.JuiceShop is provided at
          com.shen.example.di.JuiceComponent.inject()
</code></pre><h3 id="-subcomponent">-@SubComponent</h3>
<p><code>@SubComponent</code>声明的接口或者抽象类，表示其本身的依赖关系图是不完整的，必须通过依附于外部的Component才能获得完整的依赖关系。使用<code>@SubComponent</code>有两种方式，第一种是通过在被依赖的Component中声明返回SubComponent类型的方法，并使用SubComponent中声明的需要传入参数的Module作为参数。第二种是在Component声明的Module中，通过Module.subcomponents指定这个Module可以为哪些SubComponent提供依赖来源。<br>
我们先看第一种方法，对比使用dependencies方式，只需要改变以下两个类：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
    <span class="c1">// 通过在被依赖的Component中声明返回SubComponent类型的方法，
</span><span class="c1"></span>    <span class="c1">// 并使用SubComponent中声明的需要传入参数的Module作为参数。
</span><span class="c1"></span>    <span class="c1">// 由于JuiceComponent没有指定有参的Module，因此这里方法的参数可以为空
</span><span class="c1"></span>    <span class="n">JuiceComponent</span> <span class="nf">juiceComponent</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 将JuiceComponent标注为Subcomponent，去掉dependencies指定
</span><span class="c1"></span><span class="nd">@OtherScop</span>
<span class="nd">@Subcomponent</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">JuiceModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JuiceComponent</span> <span class="o">{</span>
    <span class="n">JuiceShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div><p>我们可以如下构建一个<code>JuiceShop</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span>
                <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">build</span><span class="o">().</span><span class="na">juiceComponent</span><span class="o">()</span>
                <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">juiceShop</span><span class="o">.</span><span class="na">getJuice</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div><p>我们来看生成的<code>DaggerFruitComponent</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
    <span class="c1">// 通过FruitComponent中转至JuiceComponent
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">JuiceComponent</span> <span class="nf">juiceComponent</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">JuiceComponentImpl</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">JuiceComponentImpl</span> <span class="kd">implements</span> <span class="n">JuiceComponent</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">AppleJuice_Factory</span> <span class="n">appleJuiceProvider</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Juice</span><span class="o">&gt;</span> <span class="n">bindAppleJuiceProvider</span><span class="o">;</span>

        <span class="kd">private</span> <span class="nf">JuiceComponentImpl</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">initialize</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">appleJuiceProvider</span> <span class="o">=</span> <span class="n">AppleJuice_Factory</span><span class="o">.</span><span class="na">create</span><span class="o">((</span><span class="n">Provider</span><span class="o">)</span> <span class="n">Apple_Factory</span><span class="o">.</span><span class="na">create</span><span class="o">());</span>
            <span class="k">this</span><span class="o">.</span><span class="na">bindAppleJuiceProvider</span> <span class="o">=</span> <span class="n">DoubleCheck</span><span class="o">.</span><span class="na">provider</span><span class="o">((</span><span class="n">Provider</span><span class="o">)</span> <span class="n">appleJuiceProvider</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 最终会通过中转得到的JuiceComponent，调用inject方法得到目标对象
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">JuiceShop</span> <span class="nf">inject</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">injectJuiceShop</span><span class="o">(</span><span class="n">JuiceShop_Factory</span><span class="o">.</span><span class="na">newJuiceShop</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="nd">@CanIgnoreReturnValue</span>
        <span class="kd">private</span> <span class="n">JuiceShop</span> <span class="nf">injectJuiceShop</span><span class="o">(</span><span class="n">JuiceShop</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">JuiceShop_MembersInjector</span><span class="o">.</span><span class="na">injectAppleJuice</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">bindAppleJuiceProvider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>可以看出，当使用@SubModule时，<code>JuiceComponent</code>被声明为<code>FruitComponent</code>的内部类，通过内部中转至<code>JuiceComponent</code>从而构造出目标对象。<br>
第二种使用@Module.subcomponents，相比第一种SubComponent方法而言，不需要在在被依赖的Component中声明返回SubComponent类型的方法，只需要在被依赖的Component对应的Module中声明subcomponent既可。同时对SubComponent要求有@Subcomponent.Builder。<br>
我们看FruitComponent不在需要声明返回JuiceComponent的方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">FruitModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
    <span class="c1">// 不需要额外声明SubComponent
</span><span class="c1"></span>    <span class="c1">//JuiceComponent juiceComponent();
</span><span class="c1"></span><span class="o">}</span>

<span class="nd">@OtherScop</span>
<span class="nd">@Subcomponent</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">JuiceModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JuiceComponent</span> <span class="o">{</span>
    <span class="n">JuiceShop</span> <span class="nf">inject</span><span class="o">();</span>

    <span class="c1">// 需要添加SubComponent.Builder
</span><span class="c1"></span>    <span class="nd">@Subcomponent.Builder</span>
    <span class="kd">interface</span> <span class="nc">Builder</span> <span class="o">{</span>
        <span class="n">JuiceComponent</span> <span class="nf">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>同时对于JuiceComponent需要依赖的module添加subComponent依赖</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 对Module加入subcomponents = {JuiceComponent.class}
</span><span class="c1"></span><span class="nd">@Module</span><span class="o">(</span><span class="n">subcomponents</span> <span class="o">=</span> <span class="o">{</span><span class="n">JuiceComponent</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">abstract</span> <span class="kd">public</span>  <span class="kd">class</span> <span class="nc">FruitModule</span> <span class="o">{</span>

    <span class="nd">@Binds</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;apple&#34;</span><span class="o">)</span>
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindApple</span><span class="o">(</span><span class="n">Apple</span> <span class="n">apple</span><span class="o">);</span>

    <span class="nd">@Binds</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;orange&#34;</span><span class="o">)</span>
    <span class="kd">abstract</span> <span class="n">Fruit</span> <span class="nf">bindOrange</span><span class="o">(</span><span class="n">Orange</span> <span class="n">orange</span><span class="o">);</span>

<span class="o">}</span>
</code></pre></div><p>这个时候可以在被依赖的Component生成产物的FruitShop中构造出JuiceShop</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="c1">// 这里可以直接使用JuiceComponent.Builder，Provider的作用后面再说
</span><span class="c1"></span>    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&gt;</span> <span class="n">juiceComponentProvider</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">juice</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 通过声明需要注入一个JuiceComponent，从而获得JuiceShop
</span><span class="c1"></span>        <span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">juiceComponentProvider</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">build</span><span class="o">().</span><span class="na">inject</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">juiceShop</span><span class="o">.</span><span class="na">getJuice</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div><p>从生成的DaggerFruitComponent来看</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">DaggerFruitComponent</span> <span class="kd">implements</span> <span class="n">FruitComponent</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&gt;</span> <span class="n">juiceComponentBuilderProvider</span><span class="o">;</span>
  
  <span class="c1">// 初始化juiceComponentBuilderProvider
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="kd">final</span> <span class="n">Builder</span> <span class="n">builder</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">juiceComponentBuilderProvider</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&gt;()</span> <span class="o">{</span>
          <span class="nd">@Override</span>
          <span class="kd">public</span> <span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">JuiceComponentBuilder</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">};</span>
  <span class="o">}</span>
  
  <span class="c1">// 将juiceComponentBuilderProvider注入到FruitShop中
</span><span class="c1"></span>  <span class="kd">private</span> <span class="n">FruitShop</span> <span class="nf">injectFruitShop</span><span class="o">(</span><span class="n">FruitShop</span> <span class="n">instance</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">FruitShop_MembersInjector</span><span class="o">.</span><span class="na">injectJuiceComponentProvider</span><span class="o">(</span><span class="n">instance</span><span class="o">,</span> <span class="n">juiceComponentBuilderProvider</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">JuiceComponentBuilder</span> <span class="kd">implements</span> <span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span> <span class="o">{</span>
    <span class="c1">// 通过JuiceComponent.Builder生成JuiceComponentImpl，这就是为什么通过@Module.subcomponents一定要声明Builder的原因。
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">JuiceComponent</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">JuiceComponentImpl</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="c1">// JuiceComponentImpl与第一种的SubComponent方法内容类似，省略
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">JuiceComponentImpl</span> <span class="kd">implements</span> <span class="n">JuiceComponent</span> <span class="o">{</span>
    <span class="c1">// ……
</span><span class="c1"></span>  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="-指定dependencies与subcomponent区别">-指定dependencies与SubComponent区别</h3>
<ul>
<li>dependencies可以同时指定多个，而采用SubComponent只能有一个parent Component</li>
<li>dependencies指定的Component与本身的Component是属于组合关系，他们各自独立，可以单独使用。而SubComponent必须依赖于某个Component，Dagger不会对SubComponent生成DaggerXXXSubComponent类，而是在DaggerXXXComponent中定义了SubComponentImpl的内部类。</li>
<li>调用生成对象的时候依赖方向不同。使用dependencies方式，需要外部依赖的Componet和被依赖的Componet之间相互独立，会生成两个DaggerXXXComponet，并且是通过需要依赖的Componet发起，通过引入外部的Component来构建出最终的对象；而通过<code>@SubComponent</code>方式则是只生成一个DaggerXXXComponent，由被依赖的Component发起，通过中转至需要其依赖的内部Component或者从依赖的Component生成对象内部来构建出最终对象。见如下代码：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// dependencies方式
</span><span class="c1"></span><span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">DaggerJuiceComponent</span>
                <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">fruitComponent</span><span class="o">(</span><span class="n">DaggerFruitComponent</span><span class="o">.</span><span class="na">create</span><span class="o">())</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">inject</span><span class="o">();</span>

<span class="c1">// @SubComponent第一种方式
</span><span class="c1"></span><span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span>
        <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">build</span><span class="o">().</span><span class="na">juiceComponent</span><span class="o">()</span>
        <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
        
<span class="c1">// @SubComponent第二种方式
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="n">Provider</span><span class="o">&lt;</span><span class="n">JuiceComponent</span><span class="o">.</span><span class="na">Builder</span><span class="o">&gt;</span> <span class="n">juiceComponentProvider</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">FruitShop</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createJuiceShop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">JuiceShop</span> <span class="n">juiceShop</span> <span class="o">=</span> <span class="n">juiceComponentProvider</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">build</span><span class="o">().</span><span class="na">inject</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>  使用SubComponent的有两个好处，第一个是可以对不同的component声明不同的生命周期，规范对象存活的周期。第二个是为了更好的封装，将相同的依赖放置到同一个component并依赖于它，而将不同的依赖封装到不同的模块。<br>
  对于Component的依赖关系介绍到这里。在平常的使用中，如果module之间依赖较多的话，不建议采用@SubComponent第一种方式，因为这种方式每增加一个submodule都要在被依赖的component中声明。如果被依赖的component比较稳定，建议使用dependencies方式，这样新增加一个依赖的component不用修改被依赖的component。而@SubComponent第二种方式仅适用于依赖的component是作为被依赖component的一个附属情况下使用，因为subcomponent无法脱离被依赖component的构建产物使用。不过第二种@SubComponent方式相对第一种方式而言，会让Dagger知道SubComponent是否被使用，从而减少生成没有被使用的SubComponent的代码。</p>
<h2 id="lazy--provider">Lazy&lt;&gt; &amp; Provider&lt;&gt;</h2>
<p>依赖注入有三种模式，一种是最常见的直接注入（Direct Injection），还有就是懒注入（Lazy Injection）和提供者注入（Provider Injection）。直接注入模式下，被注入的对象会先生成，然后当有需要被注入的地方时，将预先生成的对象赋值到需要的地方。Lazy注入只有当get的时候才会创建对象，且生成之后对象会被缓存下来。Provider注入在每次get都会创建新的对象。<br>
用官方的一个例子来说明。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CounterModule</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">100</span><span class="o">;</span>

    <span class="nd">@Provides</span>
    <span class="n">Integer</span> <span class="nf">provideInteger</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;computing...&#34;</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">next</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p><code>CounterModule</code>可以提供一个整形变量，每次提供完之后会对这个变量加一。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 直接注入
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectCounter</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">Integer</span> <span class="n">value</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;direct counter printing...&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Provider注入
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProviderCounter</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">Provider</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">provider</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;provider counter printing...&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">provider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">provider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">provider</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * Lazy注入
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyCounter</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">Lazy</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">lazy</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;lazy counter printing...&#34;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lazy</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lazy</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lazy</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * 多个Lazy注入，lazy与单例
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyCounters</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">LazyCounter</span> <span class="n">counter1</span><span class="o">;</span>
    <span class="nd">@Inject</span>
    <span class="n">LazyCounter</span> <span class="n">counter2</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;lazy counters printing...&#34;</span><span class="o">);</span>
        <span class="n">counter1</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="n">counter2</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>我们将这几种的Counter集合到一起并输入</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="nd">@Inject</span>
    <span class="n">DirectCounter</span> <span class="n">mDirectCounter</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">ProviderCounter</span> <span class="n">mProviderCounter</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">LazyCounter</span> <span class="n">mLazyCounter</span><span class="o">;</span>

    <span class="nd">@Inject</span>
    <span class="n">LazyCounters</span> <span class="n">mLazyCounters</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mDirectCounter</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="n">mProviderCounter</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="n">mLazyCounter</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="n">mLazyCounters</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>得到以下的输入结果：</p>
<pre><code>// 直接注入
computing...
direct counter printing...
100
100
100
// Provider注入
provider counter printing...
computing...
101
computing...
102
computing...
103
// Lazy注入
lazy counter printing...
computing...
104
104
104
// 多个Lazy注入
lazy counters printing...
lazy counter printing...
computing...
105
105
105
lazy counter printing...
computing...
106
106
106
</code></pre><p>从结果可以看出，直接注入会先计算一次得到需要被注入的依赖对象（这里是整型100），并在需要的地方都返回这个预先计算好的对象，因此都返回100。<br>
Provider注入则会在每次get方法调用的地方都通过Module中的provider方法计算得到需要被注入的依赖对象，因此依次返回新计算的对象101、102、103。<br>
Lazy注入与直接注入相似，只会计算一次需要被注入的依赖对象，但是与直接注入不同的是，Lazy注入只有在被调用get方法的时候才会进行计算，因此可以看到<code>lazy counter printing...</code>先打印，然后才是<code>computing...</code>。<br>
需要注意的是Lazy注入并不等同于单例模式，不同的<code>LazyCounter</code>的get方法会获取到不同的对象。例如<code>LazyCounters</code>中通过两个<code>LazyCounter</code>的get方法分别获取到的是105和106，并且<code>lazy counter printing...</code>和<code>computing...</code>都打印了两次。</p>
<h2 id="bindsinstance">@BindsInstance</h2>
<p>当构建Component的时候，如果需要外部传入参数，我们有两种方法，一种是通过构建Module时通过Module的构造函数传入参数，第二种是通过<code>@BindsInstance</code>方式，在构建Component的时候通过Component.Builder来构建Component。我们先看第一种方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Pear对象需要一个String类型的名称
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pear</span> <span class="kd">implements</span> <span class="n">Fruit</span> <span class="o">{</span>

    <span class="n">String</span> <span class="n">customName</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Pear</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">customName</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">name</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">customName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">customName</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">customName</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">&#34;pear&#34;</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// ProjectModule的构造函数接收一个String类型的参数，并最终用于构造Pear对象
</span><span class="c1"></span><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="n">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ProjectModule</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Provides</span> <span class="nd">@Name</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">provideName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Provides</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;pear&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">providerPear</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nd">@Name</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Pear</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Component不需要特别的处理
</span><span class="c1"></span><span class="nd">@Singleton</span>
<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitShop</span> <span class="o">{</span>

    <span class="nd">@Inject</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;pear&#34;</span><span class="o">)</span>
    <span class="n">Fruit</span> <span class="n">pear</span><span class="o">;</span>

    <span class="c1">// 打印出Pear的名字
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">createFruit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">pear</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">name</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 通过projectModule构造传递参数
</span><span class="c1"></span>        <span class="n">FruitShop</span> <span class="n">fruitShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span>
                <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">projectModule</span><span class="o">(</span><span class="k">new</span> <span class="n">ProjectModule</span><span class="o">(</span><span class="s">&#34;cus_Pear&#34;</span><span class="o">))</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fruitShop</span><span class="o">.</span><span class="na">createFruit</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>上面代码中，通过<code>ProjectModule</code>的构建函数传入了一个String对象参数，并最后用于构造<code>Pear</code>对象，最终会打印<code>cus_Pear</code>。对于这种在依赖关系图中需要外部传入参数的情况，可以使用<code>@BindInstance</code>来进行优化。优化之后的代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ProjectModule中不需要另外声明构造函数
</span><span class="c1"></span><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;pear&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">providerPear</span><span class="o">(</span><span class="nd">@Name</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Pear</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>

    <span class="c1">// 通过Component.Builder并使用BindsInstance提供依赖需要参数
</span><span class="c1"></span>    <span class="nd">@Component.Builder</span>
    <span class="kd">interface</span> <span class="nc">Builder</span> <span class="o">{</span>
        <span class="nd">@BindsInstance</span>
        <span class="n">Builder</span> <span class="nf">cusPearName</span><span class="o">(</span><span class="nd">@Name</span> <span class="n">String</span> <span class="n">name</span><span class="o">);</span>
        <span class="n">FruitComponent</span> <span class="nf">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 使用builder中的cusPearName方法传入参数
</span><span class="c1"></span>        <span class="n">FruitShop</span> <span class="n">fruitShop</span> <span class="o">=</span> <span class="n">DaggerFruitComponent</span>
                <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
                <span class="o">.</span><span class="na">cusPearName</span><span class="o">(</span><span class="s">&#34;cus_Pear&#34;</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                <span class="o">.</span><span class="na">inject</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">fruitShop</span><span class="o">.</span><span class="na">createFruit</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>与第一种方法不同，这种方法并不需要使用Module的带参数构造方法来传递依赖所需的参数，而是通过Component构造时候在build的过程中通过<code>cusPearName</code>方法传入依赖对象，逻辑更加清晰，并且减少了Module的复杂度。<br>
使用<code>@BindInstance</code>注解的方法，如果参数没有标记为<code>@Nullable</code>则这个方法必须要调用，否则会报<code>java.lang.IllegalStateException: java.lang.String must be set</code>。传入参数必须为非null，否则会报<code>java.lang.NullPointerException at dagger.internal.Preconditions.checkNotNull(Preconditions.java:33)</code>。如果这个参数是可选，则必须声明为nullable，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Module</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProjectModule</span> <span class="o">{</span>

    <span class="nd">@Provides</span> <span class="nd">@FruitType</span><span class="o">(</span><span class="s">&#34;pear&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Fruit</span> <span class="nf">providerPear</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nd">@Name</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Pear</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="n">modules</span> <span class="o">=</span> <span class="o">{</span><span class="n">ProjectModule</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FruitComponent</span> <span class="o">{</span>
    <span class="n">FruitShop</span> <span class="nf">inject</span><span class="o">();</span>

    <span class="nd">@Component.Builder</span>
    <span class="kd">interface</span> <span class="nc">Builder</span> <span class="o">{</span>
        <span class="nd">@BindsInstance</span>
        <span class="n">Builder</span> <span class="nf">cusPearName</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nd">@Name</span> <span class="n">String</span> <span class="n">name</span><span class="o">);</span>
        <span class="n">FruitComponent</span> <span class="nf">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在实际项目中，应该尽量使用<code>@BindInstance</code>，而不是带参数构造函数的module。</p>
<h2 id="bindsoptionalof">@BindsOptionalOf</h2>
<h2 id="mapkey">@MapKey</h2>
<h2 id="multibinds">@Multibinds</h2>
<h2 id="intomap--intoset--elementsintoset">@IntoMap  @IntoSet  @ElementsIntoSet</h2>
<h2 id="stringkey-intkey-longkey-classkey">@StringKey @IntKey @LongKey @ClassKey</h2>
<h1 id="dagger2的缺点">Dagger2的缺点</h1>
<ul>
<li>修改完相关依赖之后必须Rebuild才能生效</li>
<li>代码检索变得相对困难，对于接口或者抽象类没办法直观看到具体生成的是哪个对象
Kodein</li>
<li>编写Dagger代码时需要关注比较多的规则约束，且不太容易记忆（例如Component中的方法要求，以及Builder里的方法要求等）</li>
</ul>
<h1 id="最后">最后</h1>
<p>Dagger2是非常棒的依赖注入器，但是Dagger2使用存在上述的一些缺点，所以建议仅在如架构关系之类的关键且依赖关系相对不经常修改的地方使用，不建议在项目中大范围使用。</p>
<h1 id="例子代码下载">例子代码下载：</h1>
<p>本文的代码可以在github中下载：https://github.com/shenguojun/DaggerExample</p>


        
          <div class="blog-tags">
            
              <a href="https://shenguojun.github.io//tags/android/">android</a>&nbsp;
            
          </div>
        

        
            <hr/>
            <section id="social-share">
              <div class="list-inline footer-links">
                

<div class="share-box" aria-hidden="true">
    <ul class="share">
      
      <li>
        <a href="//twitter.com/share?url=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f&amp;text=Dagger2%e6%b3%a8%e8%a7%a3%e5%a4%a7%e5%85%a8&amp;via=" target="_blank" title="Share on Twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f" target="_blank" title="Share on Facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//reddit.com/submit?url=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f&amp;title=Dagger2%e6%b3%a8%e8%a7%a3%e5%a4%a7%e5%85%a8" target="_blank" title="Share on Reddit">
          <i class="fab fa-reddit"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f&amp;title=Dagger2%e6%b3%a8%e8%a7%a3%e5%a4%a7%e5%85%a8" target="_blank" title="Share on LinkedIn">
          <i class="fab fa-linkedin"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f&amp;title=Dagger2%e6%b3%a8%e8%a7%a3%e5%a4%a7%e5%85%a8" target="_blank" title="Share on StumbleUpon">
          <i class="fab fa-stumbleupon"></i>
        </a>
      </li>
  
      
      <li>
        <a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fshenguojun.github.io%2fpost%2fdagger2-annotation%2f&amp;description=Dagger2%e6%b3%a8%e8%a7%a3%e5%a4%a7%e5%85%a8" target="_blank" title="Share on Pinterest">
          <i class="fab fa-pinterest"></i>
        </a>
      </li>
    </ul>
  </div>
  

              </div>
            </section>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://shenguojun.github.io/post/android-pinned-shortcut/" data-toggle="tooltip" data-placement="top" title="Android create pinned shortcut创建桌面快捷方式">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://shenguojun.github.io/post/databinding-submodule/" data-toggle="tooltip" data-placement="top" title="Databinding subModule library 爬坑">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
                <a href="mailto:junguoshen@yeah.net" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/shenguojun" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://linkedin.com/in/guojunshen" title="LinkedIn">
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              申国骏
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2021
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://shenguojun.github.io/">Lawrence&#39;s Blog</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="https://gohugo.io">Hugo v0.83.1</a> powered &nbsp;&bull;&nbsp; Theme <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> adapted from <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://shenguojun.github.io/js/main.js"></script>
<script src="https://shenguojun.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://shenguojun.github.io/js/load-photoswipe.js"></script>









    
  </body>
</html>

